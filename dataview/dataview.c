/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview.h"



flag asn1SccMyInt_Equal(const asn1SccMyInt* pVal1, const asn1SccMyInt* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMyInt_IsConstraintValid(const asn1SccMyInt* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-100LL <= (*(pVal))) && ((*(pVal)) <= 100LL));
    *pErrCode = ret ? 0 :  ERR_MYINT;

	return ret;
}

#ifdef __cplusplus
const asn1SccMyInt asn1SccMyInt_constant = 0LL;
#endif

void asn1SccMyInt_Initialize(asn1SccMyInt* pVal)
{
	(void)pVal;


	(*(pVal)) = (asn1SccMyInt)asn1SccMyInt_constant;
}

flag asn1SccMyInt_Encode(const asn1SccMyInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -100, 100);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMyInt_Decode(asn1SccMyInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -100, 100);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINT;

	return ret  && asn1SccMyInt_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyInt_ACN_Encode(const asn1SccMyInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInt_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_TwosComplement_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMyInt_ACN_Decode(asn1SccMyInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_TwosComplement_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINT;

    return ret && asn1SccMyInt_IsConstraintValid(pVal, pErrCode);
}


flag asn1SccMyInt2_Equal(const asn1SccMyInt2* pVal1, const asn1SccMyInt2* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMyInt2_IsConstraintValid(const asn1SccMyInt2* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1000UL);
    *pErrCode = ret ? 0 :  ERR_MYINT2;

	return ret;
}

#ifdef __cplusplus
const asn1SccMyInt2 asn1SccMyInt2_constant = 0UL;
#endif

void asn1SccMyInt2_Initialize(asn1SccMyInt2* pVal)
{
	(void)pVal;


	(*(pVal)) = (asn1SccMyInt2)asn1SccMyInt2_constant;
}

flag asn1SccMyInt2_Encode(const asn1SccMyInt2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInt2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMyInt2_Decode(asn1SccMyInt2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINT2;

	return ret  && asn1SccMyInt2_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyInt2_ACN_Encode(const asn1SccMyInt2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInt2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMyInt2_ACN_Decode(asn1SccMyInt2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINT2;

    return ret && asn1SccMyInt2_IsConstraintValid(pVal, pErrCode);
}


flag asn1SccMySeq_a1_Equal(const asn1SccMySeq_a1* pVal1, const asn1SccMySeq_a1* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMySeq_a2_Equal(const asn1SccMySeq_a2* pVal1, const asn1SccMySeq_a2* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccMySeq_Equal(const asn1SccMySeq* pVal1, const asn1SccMySeq* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccMySeq_a1_Equal((&(pVal1->a1)), (&(pVal2->a1)));

    if (ret) {
        ret = asn1SccMySeq_a2_Equal((&(pVal1->a2)), (&(pVal2->a2)));

        if (ret) {
            ret = (pVal1->a3 == pVal2->a3);

            if (ret) {
                ret = (pVal1->a4 == pVal2->a4);

            }

        }

    }

	return ret;

}

flag asn1SccMySeq_a1_IsConstraintValid(const asn1SccMySeq_a1* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 20UL));
    *pErrCode = ret ? 0 :  ERR_MYSEQ_A1;

	return ret;
}

flag asn1SccMySeq_a2_IsConstraintValid(const asn1SccMySeq_a2* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-10LL <= (*(pVal))) && ((*(pVal)) <= 20LL));
    *pErrCode = ret ? 0 :  ERR_MYSEQ_A2;

	return ret;
}

flag asn1SccMySeq_IsConstraintValid(const asn1SccMySeq* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccMySeq_a1_IsConstraintValid((&(pVal->a1)), pErrCode);
    if (ret) {
        ret = asn1SccMySeq_a2_IsConstraintValid((&(pVal->a2)), pErrCode);
        if (ret) {
            ret = asn1SccMyInt_IsConstraintValid((&(pVal->a3)), pErrCode);
            if (ret) {
                ret = asn1SccMyInt2_IsConstraintValid((&(pVal->a4)), pErrCode);
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const asn1SccMySeq_a1 asn1SccMySeq_a1_constant = 1UL;
#endif
#ifdef __cplusplus
const asn1SccMySeq_a2 asn1SccMySeq_a2_constant = 0LL;
#endif
#ifdef __cplusplus
const asn1SccMySeq asn1SccMySeq_constant = {.a1 = 1UL, .a2 = 0LL, .a3 = 0LL, .a4 = 0UL};
#endif

void asn1SccMySeq_Initialize(asn1SccMySeq* pVal)
{
	(void)pVal;


	(*(pVal)) = (asn1SccMySeq)asn1SccMySeq_constant;
}

flag asn1SccMySeq_Encode(const asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode a1 */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->a1, 1, 20);
	    if (ret) {
	        /*Encode a2 */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->a2, -10, 20);
	        if (ret) {
	            /*Encode a3 */
	            ret = asn1SccMyInt_Encode((&(pVal->a3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode a4 */
	                ret = asn1SccMyInt2_Encode((&(pVal->a4)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMySeq_Decode(asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode a1 */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->a1)), 1, 20);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQ_A1;
	if (ret) {
	    /*Decode a2 */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->a2)), -10, 20);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MYSEQ_A2;
	    if (ret) {
	        /*Decode a3 */
	        ret = asn1SccMyInt_Decode((&(pVal->a3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode a4 */
	            ret = asn1SccMyInt2_Decode((&(pVal->a4)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && asn1SccMySeq_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMySeq_ACN_Encode(const asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode a1 */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->a1, 1, 20);
	    if (ret) {
	        /*Encode a2 */
	        Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(pBitStrm, pVal->a2);
	        if (ret) {
	            /*Encode a3 */
	            ret = asn1SccMyInt_ACN_Encode((&(pVal->a3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode a4 */
	                ret = asn1SccMyInt2_ACN_Encode((&(pVal->a4)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag asn1SccMySeq_ACN_Decode(asn1SccMySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode a1 */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->a1)), 1, 20);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQ_A1;
	if (ret) {
	    /*Decode a2 */
	    ret = Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(pBitStrm, (&(pVal->a2)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_MYSEQ_A2;
	    if (ret) {
	        /*Decode a3 */
	        ret = asn1SccMyInt_ACN_Decode((&(pVal->a3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode a4 */
	            ret = asn1SccMyInt2_ACN_Decode((&(pVal->a4)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && asn1SccMySeq_IsConstraintValid(pVal, pErrCode);
}


