/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview.h"



flag cfdpDirectiveCode_Equal(const cfdpDirectiveCode* pVal1, const cfdpDirectiveCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveCode_IsConstraintValid(const cfdpDirectiveCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == DirectiveCode_eof_pdu)) || (((*(pVal)) == DirectiveCode_finished_pdu)))) || (((*(pVal)) == DirectiveCode_ack_pdu)))) || (((*(pVal)) == DirectiveCode_metadata_pdu)))) || (((*(pVal)) == DirectiveCode_nak_pdu)))) || (((*(pVal)) == DirectiveCode_prompt_pdu)))) || (((*(pVal)) == DirectiveCode_keep_alive_pdu)));
    *pErrCode = ret ? 0 :  ERR_DIRECTIVECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveCode cfdpDirectiveCode_constant = DirectiveCode_eof_pdu;
#endif

void cfdpDirectiveCode_Initialize(cfdpDirectiveCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveCode)cfdpDirectiveCode_constant;
}

flag cfdpDirectiveCode_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DirectiveCode_eof_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case DirectiveCode_finished_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case DirectiveCode_ack_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case DirectiveCode_metadata_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case DirectiveCode_nak_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case DirectiveCode_prompt_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case DirectiveCode_keep_alive_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTIVECODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVECODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DirectiveCode_eof_pdu;
	                break;
	            case 1:
	                (*(pVal)) = DirectiveCode_finished_pdu;
	                break;
	            case 2:
	                (*(pVal)) = DirectiveCode_ack_pdu;
	                break;
	            case 3:
	                (*(pVal)) = DirectiveCode_metadata_pdu;
	                break;
	            case 4:
	                (*(pVal)) = DirectiveCode_nak_pdu;
	                break;
	            case 5:
	                (*(pVal)) = DirectiveCode_prompt_pdu;
	                break;
	            case 6:
	                (*(pVal)) = DirectiveCode_keep_alive_pdu;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTIVECODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DirectiveCode_eof_pdu;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveCode_ACN_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DirectiveCode_eof_pdu:
	            intVal_pVal = 0UL;
	            break;
	        case DirectiveCode_finished_pdu:
	            intVal_pVal = 1UL;
	            break;
	        case DirectiveCode_ack_pdu:
	            intVal_pVal = 2UL;
	            break;
	        case DirectiveCode_metadata_pdu:
	            intVal_pVal = 3UL;
	            break;
	        case DirectiveCode_nak_pdu:
	            intVal_pVal = 4UL;
	            break;
	        case DirectiveCode_prompt_pdu:
	            intVal_pVal = 5UL;
	            break;
	        case DirectiveCode_keep_alive_pdu:
	            intVal_pVal = 6UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTIVECODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_ACN_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVECODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DirectiveCode_eof_pdu;
	            break;
	        case 1:
	            (*(pVal)) = DirectiveCode_finished_pdu;
	            break;
	        case 2:
	            (*(pVal)) = DirectiveCode_ack_pdu;
	            break;
	        case 3:
	            (*(pVal)) = DirectiveCode_metadata_pdu;
	            break;
	        case 4:
	            (*(pVal)) = DirectiveCode_nak_pdu;
	            break;
	        case 5:
	            (*(pVal)) = DirectiveCode_prompt_pdu;
	            break;
	        case 6:
	            (*(pVal)) = DirectiveCode_keep_alive_pdu;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTIVECODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirectiveSubtypeCode_Equal(const cfdpDirectiveSubtypeCode* pVal1, const cfdpDirectiveSubtypeCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveSubtypeCode_IsConstraintValid(const cfdpDirectiveSubtypeCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DirectiveSubtypeCode_ack_others)) || (((*(pVal)) == DirectiveSubtypeCode_ack_finished)));
    *pErrCode = ret ? 0 :  ERR_DIRECTIVESUBTYPECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveSubtypeCode cfdpDirectiveSubtypeCode_constant = DirectiveSubtypeCode_ack_others;
#endif

void cfdpDirectiveSubtypeCode_Initialize(cfdpDirectiveSubtypeCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveSubtypeCode)cfdpDirectiveSubtypeCode_constant;
}

flag cfdpDirectiveSubtypeCode_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DirectiveSubtypeCode_ack_others:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DirectiveSubtypeCode_ack_finished:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTIVESUBTYPECODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DirectiveSubtypeCode_ack_others;
	                break;
	            case 1:
	                (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DirectiveSubtypeCode_ack_others;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveSubtypeCode_ACN_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DirectiveSubtypeCode_ack_others:
	            intVal_pVal = 0UL;
	            break;
	        case DirectiveSubtypeCode_ack_finished:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_ACN_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DirectiveSubtypeCode_ack_others;
	            break;
	        case 1:
	            (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpConditionCode_Equal(const cfdpConditionCode* pVal1, const cfdpConditionCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpConditionCode_IsConstraintValid(const cfdpConditionCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((*(pVal)) == ConditionCode_no_error)) || (((*(pVal)) == ConditionCode_positive_ack_limit_reached)))) || (((*(pVal)) == ConditionCode_keep_alive_limit_reached)))) || (((*(pVal)) == ConditionCode_invalid_transmission_mode)))) || (((*(pVal)) == ConditionCode_filestore_rejection)))) || (((*(pVal)) == ConditionCode_file_checksum_failure)))) || (((*(pVal)) == ConditionCode_file_size_error)))) || (((*(pVal)) == ConditionCode_nak_limit_reached)))) || (((*(pVal)) == ConditionCode_inactivity_detected)))) || (((*(pVal)) == ConditionCode_invalid_file_structure)))) || (((*(pVal)) == ConditionCode_suspend_request_received)))) || (((*(pVal)) == ConditionCode_cancel_request_received)));
    *pErrCode = ret ? 0 :  ERR_CONDITIONCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpConditionCode cfdpConditionCode_constant = ConditionCode_no_error;
#endif

void cfdpConditionCode_Initialize(cfdpConditionCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpConditionCode)cfdpConditionCode_constant;
}

flag cfdpConditionCode_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ConditionCode_no_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 11);
	        	break;
	        case ConditionCode_positive_ack_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 11);
	        	break;
	        case ConditionCode_keep_alive_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 11);
	        	break;
	        case ConditionCode_invalid_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 11);
	        	break;
	        case ConditionCode_filestore_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 11);
	        	break;
	        case ConditionCode_file_checksum_failure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 11);
	        	break;
	        case ConditionCode_file_size_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 11);
	        	break;
	        case ConditionCode_nak_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 11);
	        	break;
	        case ConditionCode_inactivity_detected:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 11);
	        	break;
	        case ConditionCode_invalid_file_structure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 11);
	        	break;
	        case ConditionCode_suspend_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 11);
	        	break;
	        case ConditionCode_cancel_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 11);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONDITIONCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 11);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONDITIONCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ConditionCode_no_error;
	                break;
	            case 1:
	                (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	                break;
	            case 2:
	                (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	                break;
	            case 3:
	                (*(pVal)) = ConditionCode_invalid_transmission_mode;
	                break;
	            case 4:
	                (*(pVal)) = ConditionCode_filestore_rejection;
	                break;
	            case 5:
	                (*(pVal)) = ConditionCode_file_checksum_failure;
	                break;
	            case 6:
	                (*(pVal)) = ConditionCode_file_size_error;
	                break;
	            case 7:
	                (*(pVal)) = ConditionCode_nak_limit_reached;
	                break;
	            case 8:
	                (*(pVal)) = ConditionCode_inactivity_detected;
	                break;
	            case 9:
	                (*(pVal)) = ConditionCode_invalid_file_structure;
	                break;
	            case 10:
	                (*(pVal)) = ConditionCode_suspend_request_received;
	                break;
	            case 11:
	                (*(pVal)) = ConditionCode_cancel_request_received;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONDITIONCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ConditionCode_no_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpConditionCode_ACN_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ConditionCode_no_error:
	            intVal_pVal = 0UL;
	            break;
	        case ConditionCode_positive_ack_limit_reached:
	            intVal_pVal = 1UL;
	            break;
	        case ConditionCode_keep_alive_limit_reached:
	            intVal_pVal = 2UL;
	            break;
	        case ConditionCode_invalid_transmission_mode:
	            intVal_pVal = 3UL;
	            break;
	        case ConditionCode_filestore_rejection:
	            intVal_pVal = 4UL;
	            break;
	        case ConditionCode_file_checksum_failure:
	            intVal_pVal = 5UL;
	            break;
	        case ConditionCode_file_size_error:
	            intVal_pVal = 6UL;
	            break;
	        case ConditionCode_nak_limit_reached:
	            intVal_pVal = 7UL;
	            break;
	        case ConditionCode_inactivity_detected:
	            intVal_pVal = 8UL;
	            break;
	        case ConditionCode_invalid_file_structure:
	            intVal_pVal = 9UL;
	            break;
	        case ConditionCode_suspend_request_received:
	            intVal_pVal = 10UL;
	            break;
	        case ConditionCode_cancel_request_received:
	            intVal_pVal = 11UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_ACN_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONDITIONCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ConditionCode_no_error;
	            break;
	        case 1:
	            (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	            break;
	        case 2:
	            (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	            break;
	        case 3:
	            (*(pVal)) = ConditionCode_invalid_transmission_mode;
	            break;
	        case 4:
	            (*(pVal)) = ConditionCode_filestore_rejection;
	            break;
	        case 5:
	            (*(pVal)) = ConditionCode_file_checksum_failure;
	            break;
	        case 6:
	            (*(pVal)) = ConditionCode_file_size_error;
	            break;
	        case 7:
	            (*(pVal)) = ConditionCode_nak_limit_reached;
	            break;
	        case 8:
	            (*(pVal)) = ConditionCode_inactivity_detected;
	            break;
	        case 9:
	            (*(pVal)) = ConditionCode_invalid_file_structure;
	            break;
	        case 10:
	            (*(pVal)) = ConditionCode_suspend_request_received;
	            break;
	        case 11:
	            (*(pVal)) = ConditionCode_cancel_request_received;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDeliveryCode_Equal(const cfdpDeliveryCode* pVal1, const cfdpDeliveryCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDeliveryCode_IsConstraintValid(const cfdpDeliveryCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DeliveryCode_data_complete)) || (((*(pVal)) == DeliveryCode_data_incomplete)));
    *pErrCode = ret ? 0 :  ERR_DELIVERYCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDeliveryCode cfdpDeliveryCode_constant = DeliveryCode_data_complete;
#endif

void cfdpDeliveryCode_Initialize(cfdpDeliveryCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDeliveryCode)cfdpDeliveryCode_constant;
}

flag cfdpDeliveryCode_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DeliveryCode_data_complete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DeliveryCode_data_incomplete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DELIVERYCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DELIVERYCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DeliveryCode_data_complete;
	                break;
	            case 1:
	                (*(pVal)) = DeliveryCode_data_incomplete;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DELIVERYCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DeliveryCode_data_complete;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDeliveryCode_ACN_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DeliveryCode_data_complete:
	            intVal_pVal = 0UL;
	            break;
	        case DeliveryCode_data_incomplete:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_ACN_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DELIVERYCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DeliveryCode_data_complete;
	            break;
	        case 1:
	            (*(pVal)) = DeliveryCode_data_incomplete;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileStatus_Equal(const cfdpFileStatus* pVal1, const cfdpFileStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileStatus_IsConstraintValid(const cfdpFileStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == FileStatus_discarted_deliberately)) || (((*(pVal)) == FileStatus_discarted_file_rejection)))) || (((*(pVal)) == FileStatus_retained_successfully)))) || (((*(pVal)) == FileStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_FILESTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpFileStatus cfdpFileStatus_constant = FileStatus_discarted_deliberately;
#endif

void cfdpFileStatus_Initialize(cfdpFileStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileStatus)cfdpFileStatus_constant;
}

flag cfdpFileStatus_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case FileStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case FileStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case FileStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case FileStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_FILESTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_FILESTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = FileStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = FileStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = FileStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = FileStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_FILESTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = FileStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileStatus_ACN_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case FileStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case FileStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case FileStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case FileStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_ACN_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILESTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = FileStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = FileStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = FileStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = FileStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionStatus_Equal(const cfdpTransactionStatus* pVal1, const cfdpTransactionStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransactionStatus_IsConstraintValid(const cfdpTransactionStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == TransactionStatus_discarted_deliberately)) || (((*(pVal)) == TransactionStatus_discarted_file_rejection)))) || (((*(pVal)) == TransactionStatus_retained_successfully)))) || (((*(pVal)) == TransactionStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionStatus cfdpTransactionStatus_constant = TransactionStatus_discarted_deliberately;
#endif

void cfdpTransactionStatus_Initialize(cfdpTransactionStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionStatus)cfdpTransactionStatus_constant;
}

flag cfdpTransactionStatus_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransactionStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case TransactionStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case TransactionStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case TransactionStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSACTIONSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransactionStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = TransactionStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = TransactionStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = TransactionStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSACTIONSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransactionStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionStatus_ACN_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransactionStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case TransactionStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case TransactionStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case TransactionStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_ACN_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransactionStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = TransactionStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = TransactionStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = TransactionStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTypeFieldCode_Equal(const cfdpTypeFieldCode* pVal1, const cfdpTypeFieldCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTypeFieldCode_IsConstraintValid(const cfdpTypeFieldCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == TypeFieldCode_filestore_request)) || (((*(pVal)) == TypeFieldCode_filestore_response)))) || (((*(pVal)) == TypeFieldCode_message_to_user)))) || (((*(pVal)) == TypeFieldCode_fault_handler_overrides)))) || (((*(pVal)) == TypeFieldCode_flow_label)))) || (((*(pVal)) == TypeFieldCode_entity_id)));
    *pErrCode = ret ? 0 :  ERR_TYPEFIELDCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTypeFieldCode cfdpTypeFieldCode_constant = TypeFieldCode_filestore_request;
#endif

void cfdpTypeFieldCode_Initialize(cfdpTypeFieldCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTypeFieldCode)cfdpTypeFieldCode_constant;
}

flag cfdpTypeFieldCode_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TypeFieldCode_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case TypeFieldCode_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case TypeFieldCode_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case TypeFieldCode_fault_handler_overrides:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case TypeFieldCode_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case TypeFieldCode_entity_id:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TYPEFIELDCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TYPEFIELDCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TypeFieldCode_filestore_request;
	                break;
	            case 1:
	                (*(pVal)) = TypeFieldCode_filestore_response;
	                break;
	            case 2:
	                (*(pVal)) = TypeFieldCode_message_to_user;
	                break;
	            case 3:
	                (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	                break;
	            case 4:
	                (*(pVal)) = TypeFieldCode_flow_label;
	                break;
	            case 5:
	                (*(pVal)) = TypeFieldCode_entity_id;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TYPEFIELDCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TypeFieldCode_filestore_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTypeFieldCode_ACN_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TypeFieldCode_filestore_request:
	            intVal_pVal = 0UL;
	            break;
	        case TypeFieldCode_filestore_response:
	            intVal_pVal = 1UL;
	            break;
	        case TypeFieldCode_message_to_user:
	            intVal_pVal = 2UL;
	            break;
	        case TypeFieldCode_fault_handler_overrides:
	            intVal_pVal = 3UL;
	            break;
	        case TypeFieldCode_flow_label:
	            intVal_pVal = 4UL;
	            break;
	        case TypeFieldCode_entity_id:
	            intVal_pVal = 5UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_ACN_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TYPEFIELDCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TypeFieldCode_filestore_request;
	            break;
	        case 1:
	            (*(pVal)) = TypeFieldCode_filestore_response;
	            break;
	        case 2:
	            (*(pVal)) = TypeFieldCode_message_to_user;
	            break;
	        case 3:
	            (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	            break;
	        case 4:
	            (*(pVal)) = TypeFieldCode_flow_label;
	            break;
	        case 5:
	            (*(pVal)) = TypeFieldCode_entity_id;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpMessageType_Equal(const cfdpMessageType* pVal1, const cfdpMessageType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpMessageType_IsConstraintValid(const cfdpMessageType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((((((*(pVal)) == MessageType_proxy_put_request)) || (((*(pVal)) == MessageType_proxy_message_to_user)))) || (((*(pVal)) == MessageType_proxy_filestore_request)))) || (((*(pVal)) == MessageType_proxy_fault_handler_override)))) || (((*(pVal)) == MessageType_proxy_transmission_mode)))) || (((*(pVal)) == MessageType_proxy_flow_label)))) || (((*(pVal)) == MessageType_proxy_segmentation_control)))) || (((*(pVal)) == MessageType_proxy_put_response)))) || (((*(pVal)) == MessageType_proxy_filestore_response)))) || (((*(pVal)) == MessageType_proxy_put_cancel)))) || (((*(pVal)) == MessageType_directory_listing_request)))) || (((*(pVal)) == MessageType_directory_listing_response)))) || (((*(pVal)) == MessageType_remote_status_report_request)))) || (((*(pVal)) == MessageType_remote_status_report_response)))) || (((*(pVal)) == MessageType_remote_suspend_request)))) || (((*(pVal)) == MessageType_remote_suspend_response)))) || (((*(pVal)) == MessageType_remote_resume_request)))) || (((*(pVal)) == MessageType_remote_resume_response)));
    *pErrCode = ret ? 0 :  ERR_MESSAGETYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpMessageType cfdpMessageType_constant = MessageType_proxy_put_request;
#endif

void cfdpMessageType_Initialize(cfdpMessageType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpMessageType)cfdpMessageType_constant;
}

flag cfdpMessageType_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case MessageType_proxy_put_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 17);
	        	break;
	        case MessageType_proxy_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 17);
	        	break;
	        case MessageType_proxy_fault_handler_override:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 17);
	        	break;
	        case MessageType_proxy_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 17);
	        	break;
	        case MessageType_proxy_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 17);
	        	break;
	        case MessageType_proxy_segmentation_control:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 17);
	        	break;
	        case MessageType_proxy_put_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 17);
	        	break;
	        case MessageType_proxy_put_cancel:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 17);
	        	break;
	        case MessageType_directory_listing_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 17);
	        	break;
	        case MessageType_directory_listing_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 17);
	        	break;
	        case MessageType_remote_status_report_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 17);
	        	break;
	        case MessageType_remote_status_report_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 17);
	        	break;
	        case MessageType_remote_suspend_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 17);
	        	break;
	        case MessageType_remote_suspend_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 17);
	        	break;
	        case MessageType_remote_resume_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 16, 0, 17);
	        	break;
	        case MessageType_remote_resume_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 17, 0, 17);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MESSAGETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 17);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MESSAGETYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = MessageType_proxy_put_request;
	                break;
	            case 1:
	                (*(pVal)) = MessageType_proxy_message_to_user;
	                break;
	            case 2:
	                (*(pVal)) = MessageType_proxy_filestore_request;
	                break;
	            case 3:
	                (*(pVal)) = MessageType_proxy_fault_handler_override;
	                break;
	            case 4:
	                (*(pVal)) = MessageType_proxy_transmission_mode;
	                break;
	            case 5:
	                (*(pVal)) = MessageType_proxy_flow_label;
	                break;
	            case 6:
	                (*(pVal)) = MessageType_proxy_segmentation_control;
	                break;
	            case 7:
	                (*(pVal)) = MessageType_proxy_put_response;
	                break;
	            case 8:
	                (*(pVal)) = MessageType_proxy_filestore_response;
	                break;
	            case 9:
	                (*(pVal)) = MessageType_proxy_put_cancel;
	                break;
	            case 10:
	                (*(pVal)) = MessageType_directory_listing_request;
	                break;
	            case 11:
	                (*(pVal)) = MessageType_directory_listing_response;
	                break;
	            case 12:
	                (*(pVal)) = MessageType_remote_status_report_request;
	                break;
	            case 13:
	                (*(pVal)) = MessageType_remote_status_report_response;
	                break;
	            case 14:
	                (*(pVal)) = MessageType_remote_suspend_request;
	                break;
	            case 15:
	                (*(pVal)) = MessageType_remote_suspend_response;
	                break;
	            case 16:
	                (*(pVal)) = MessageType_remote_resume_request;
	                break;
	            case 17:
	                (*(pVal)) = MessageType_remote_resume_response;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MESSAGETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = MessageType_proxy_put_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpMessageType_ACN_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case MessageType_proxy_put_request:
	            intVal_pVal = 0UL;
	            break;
	        case MessageType_proxy_message_to_user:
	            intVal_pVal = 1UL;
	            break;
	        case MessageType_proxy_filestore_request:
	            intVal_pVal = 2UL;
	            break;
	        case MessageType_proxy_fault_handler_override:
	            intVal_pVal = 3UL;
	            break;
	        case MessageType_proxy_transmission_mode:
	            intVal_pVal = 4UL;
	            break;
	        case MessageType_proxy_flow_label:
	            intVal_pVal = 5UL;
	            break;
	        case MessageType_proxy_segmentation_control:
	            intVal_pVal = 6UL;
	            break;
	        case MessageType_proxy_put_response:
	            intVal_pVal = 7UL;
	            break;
	        case MessageType_proxy_filestore_response:
	            intVal_pVal = 8UL;
	            break;
	        case MessageType_proxy_put_cancel:
	            intVal_pVal = 9UL;
	            break;
	        case MessageType_directory_listing_request:
	            intVal_pVal = 10UL;
	            break;
	        case MessageType_directory_listing_response:
	            intVal_pVal = 11UL;
	            break;
	        case MessageType_remote_status_report_request:
	            intVal_pVal = 12UL;
	            break;
	        case MessageType_remote_status_report_response:
	            intVal_pVal = 13UL;
	            break;
	        case MessageType_remote_suspend_request:
	            intVal_pVal = 14UL;
	            break;
	        case MessageType_remote_suspend_response:
	            intVal_pVal = 15UL;
	            break;
	        case MessageType_remote_resume_request:
	            intVal_pVal = 16UL;
	            break;
	        case MessageType_remote_resume_response:
	            intVal_pVal = 17UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_ACN_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MESSAGETYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = MessageType_proxy_put_request;
	            break;
	        case 1:
	            (*(pVal)) = MessageType_proxy_message_to_user;
	            break;
	        case 2:
	            (*(pVal)) = MessageType_proxy_filestore_request;
	            break;
	        case 3:
	            (*(pVal)) = MessageType_proxy_fault_handler_override;
	            break;
	        case 4:
	            (*(pVal)) = MessageType_proxy_transmission_mode;
	            break;
	        case 5:
	            (*(pVal)) = MessageType_proxy_flow_label;
	            break;
	        case 6:
	            (*(pVal)) = MessageType_proxy_segmentation_control;
	            break;
	        case 7:
	            (*(pVal)) = MessageType_proxy_put_response;
	            break;
	        case 8:
	            (*(pVal)) = MessageType_proxy_filestore_response;
	            break;
	        case 9:
	            (*(pVal)) = MessageType_proxy_put_cancel;
	            break;
	        case 10:
	            (*(pVal)) = MessageType_directory_listing_request;
	            break;
	        case 11:
	            (*(pVal)) = MessageType_directory_listing_response;
	            break;
	        case 12:
	            (*(pVal)) = MessageType_remote_status_report_request;
	            break;
	        case 13:
	            (*(pVal)) = MessageType_remote_status_report_response;
	            break;
	        case 14:
	            (*(pVal)) = MessageType_remote_suspend_request;
	            break;
	        case 15:
	            (*(pVal)) = MessageType_remote_suspend_response;
	            break;
	        case 16:
	            (*(pVal)) = MessageType_remote_resume_request;
	            break;
	        case 17:
	            (*(pVal)) = MessageType_remote_resume_response;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpProtocolVersion_Equal(const cfdpProtocolVersion* pVal1, const cfdpProtocolVersion* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpProtocolVersion_IsConstraintValid(const cfdpProtocolVersion* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_PROTOCOLVERSION;

	return ret;
}

#ifdef __cplusplus
const cfdpProtocolVersion cfdpProtocolVersion_constant = 0UL;
#endif

void cfdpProtocolVersion_Initialize(cfdpProtocolVersion* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpProtocolVersion)cfdpProtocolVersion_constant;
}

flag cfdpProtocolVersion_Encode(const cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProtocolVersion_Decode(cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PROTOCOLVERSION;

	return ret  && cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode);
}

flag cfdpProtocolVersion_ACN_Encode(const cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProtocolVersion_ACN_Decode(cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PROTOCOLVERSION;

    return ret && cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUType_Equal(const cfdpPDUType* pVal1, const cfdpPDUType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUType_IsConstraintValid(const cfdpPDUType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == PDUType_file_directive)) || (((*(pVal)) == PDUType_file_data)));
    *pErrCode = ret ? 0 :  ERR_PDUTYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUType cfdpPDUType_constant = PDUType_file_directive;
#endif

void cfdpPDUType_Initialize(cfdpPDUType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUType)cfdpPDUType_constant;
}

flag cfdpPDUType_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case PDUType_file_directive:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case PDUType_file_data:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PDUTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUTYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = PDUType_file_directive;
	                break;
	            case 1:
	                (*(pVal)) = PDUType_file_data;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PDUTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PDUType_file_directive;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUType_ACN_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case PDUType_file_directive:
	            intVal_pVal = 0UL;
	            break;
	        case PDUType_file_data:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PDUTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_ACN_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUTYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = PDUType_file_directive;
	            break;
	        case 1:
	            (*(pVal)) = PDUType_file_data;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PDUTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirection_Equal(const cfdpDirection* pVal1, const cfdpDirection* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirection_IsConstraintValid(const cfdpDirection* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == Direction_toward_receiver)) || (((*(pVal)) == Direction_toward_sender)));
    *pErrCode = ret ? 0 :  ERR_DIRECTION;

	return ret;
}

#ifdef __cplusplus
const cfdpDirection cfdpDirection_constant = Direction_toward_receiver;
#endif

void cfdpDirection_Initialize(cfdpDirection* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirection)cfdpDirection_constant;
}

flag cfdpDirection_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case Direction_toward_receiver:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case Direction_toward_sender:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTION;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = Direction_toward_receiver;
	                break;
	            case 1:
	                (*(pVal)) = Direction_toward_sender;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = Direction_toward_receiver;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirection_ACN_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case Direction_toward_receiver:
	            intVal_pVal = 0UL;
	            break;
	        case Direction_toward_sender:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_ACN_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTION;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = Direction_toward_receiver;
	            break;
	        case 1:
	            (*(pVal)) = Direction_toward_sender;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransmissionMode_Equal(const cfdpTransmissionMode* pVal1, const cfdpTransmissionMode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransmissionMode_IsConstraintValid(const cfdpTransmissionMode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == TransmissionMode_acknowledged)) || (((*(pVal)) == TransmissionMode_unacknowledged)));
    *pErrCode = ret ? 0 :  ERR_TRANSMISSIONMODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTransmissionMode cfdpTransmissionMode_constant = TransmissionMode_acknowledged;
#endif

void cfdpTransmissionMode_Initialize(cfdpTransmissionMode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransmissionMode)cfdpTransmissionMode_constant;
}

flag cfdpTransmissionMode_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransmissionMode_acknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case TransmissionMode_unacknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSMISSIONMODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSMISSIONMODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransmissionMode_acknowledged;
	                break;
	            case 1:
	                (*(pVal)) = TransmissionMode_unacknowledged;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSMISSIONMODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransmissionMode_acknowledged;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransmissionMode_ACN_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransmissionMode_acknowledged:
	            intVal_pVal = 0UL;
	            break;
	        case TransmissionMode_unacknowledged:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_ACN_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSMISSIONMODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransmissionMode_acknowledged;
	            break;
	        case 1:
	            (*(pVal)) = TransmissionMode_unacknowledged;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpCRCFlag_Equal(const cfdpCRCFlag* pVal1, const cfdpCRCFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpCRCFlag_IsConstraintValid(const cfdpCRCFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == CRCFlag_crc_not_present)) || (((*(pVal)) == CRCFlag_crc_present)));
    *pErrCode = ret ? 0 :  ERR_CRCFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpCRCFlag cfdpCRCFlag_constant = CRCFlag_crc_not_present;
#endif

void cfdpCRCFlag_Initialize(cfdpCRCFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpCRCFlag)cfdpCRCFlag_constant;
}

flag cfdpCRCFlag_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case CRCFlag_crc_not_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case CRCFlag_crc_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CRCFLAG; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CRCFLAG;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = CRCFlag_crc_not_present;
	                break;
	            case 1:
	                (*(pVal)) = CRCFlag_crc_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CRCFLAG;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = CRCFlag_crc_not_present;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpCRCFlag_ACN_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case CRCFlag_crc_not_present:
	            intVal_pVal = 0UL;
	            break;
	        case CRCFlag_crc_present:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_ACN_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CRCFLAG;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = CRCFlag_crc_not_present;
	            break;
	        case 1:
	            (*(pVal)) = CRCFlag_crc_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUDataFieldLength_Equal(const cfdpPDUDataFieldLength* pVal1, const cfdpPDUDataFieldLength* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUDataFieldLength_IsConstraintValid(const cfdpPDUDataFieldLength* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_PDUDATAFIELDLENGTH;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUDataFieldLength cfdpPDUDataFieldLength_constant = 0UL;
#endif

void cfdpPDUDataFieldLength_Initialize(cfdpPDUDataFieldLength* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUDataFieldLength)cfdpPDUDataFieldLength_constant;
}

flag cfdpPDUDataFieldLength_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUDATAFIELDLENGTH;

	return ret  && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUDataFieldLength_ACN_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_ACN_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUDATAFIELDLENGTH;

    return ret && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfEntityIds_Equal(const cfdpLengthOfEntityIds* pVal1, const cfdpLengthOfEntityIds* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfEntityIds_IsConstraintValid(const cfdpLengthOfEntityIds* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFENTITYIDS;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfEntityIds cfdpLengthOfEntityIds_constant = 0UL;
#endif

void cfdpLengthOfEntityIds_Initialize(cfdpLengthOfEntityIds* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfEntityIds)cfdpLengthOfEntityIds_constant;
}

flag cfdpLengthOfEntityIds_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFENTITYIDS;

	return ret  && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfEntityIds_ACN_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_ACN_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFENTITYIDS;

    return ret && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfTransactionSequenceNumber_Equal(const cfdpLengthOfTransactionSequenceNumber* pVal1, const cfdpLengthOfTransactionSequenceNumber* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(const cfdpLengthOfTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfTransactionSequenceNumber cfdpLengthOfTransactionSequenceNumber_constant = 0UL;
#endif

void cfdpLengthOfTransactionSequenceNumber_Initialize(cfdpLengthOfTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfTransactionSequenceNumber)cfdpLengthOfTransactionSequenceNumber_constant;
}

flag cfdpLengthOfTransactionSequenceNumber_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret  && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

    return ret && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpEntityId_Equal(const cfdpEntityId* pVal1, const cfdpEntityId* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpEntityId_IsConstraintValid(const cfdpEntityId* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_ENTITYID;

	return ret;
}

#ifdef __cplusplus
const cfdpEntityId cfdpEntityId_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpEntityId_Initialize(cfdpEntityId* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpEntityId)cfdpEntityId_constant;
}

flag cfdpEntityId_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}

flag cfdpEntityId_ACN_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_ACN_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionSequenceNumber_Equal(const cfdpTransactionSequenceNumber* pVal1, const cfdpTransactionSequenceNumber* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpTransactionSequenceNumber_IsConstraintValid(const cfdpTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionSequenceNumber cfdpTransactionSequenceNumber_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpTransactionSequenceNumber_Initialize(cfdpTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionSequenceNumber)cfdpTransactionSequenceNumber_constant;
}

flag cfdpTransactionSequenceNumber_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionSequenceNumber_ACN_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_ACN_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUHeader_Equal(const cfdpPDUHeader* pVal1, const cfdpPDUHeader* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->version == pVal2->version);

    if (ret) {
        ret = (pVal1->pdu_type == pVal2->pdu_type);

        if (ret) {
            ret = (pVal1->direction == pVal2->direction);

            if (ret) {
                ret = (pVal1->transmission_mode == pVal2->transmission_mode);

                if (ret) {
                    ret = (pVal1->crc_flag == pVal2->crc_flag);

                    if (ret) {
                        ret = (pVal1->pdu_data_field_length == pVal2->pdu_data_field_length);

                        if (ret) {
                            ret = cfdpEntityId_Equal((&(pVal1->source_entity_id)), (&(pVal2->source_entity_id)));

                            if (ret) {
                                ret = cfdpTransactionSequenceNumber_Equal((&(pVal1->transaction_sequence_number)), (&(pVal2->transaction_sequence_number)));

                                if (ret) {
                                    ret = cfdpEntityId_Equal((&(pVal1->destination_entity_id)), (&(pVal2->destination_entity_id)));

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag cfdpPDUHeader_IsConstraintValid(const cfdpPDUHeader* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpProtocolVersion_IsConstraintValid((&(pVal->version)), pErrCode);
    if (ret) {
        ret = cfdpPDUType_IsConstraintValid((&(pVal->pdu_type)), pErrCode);
        if (ret) {
            ret = cfdpDirection_IsConstraintValid((&(pVal->direction)), pErrCode);
            if (ret) {
                ret = cfdpTransmissionMode_IsConstraintValid((&(pVal->transmission_mode)), pErrCode);
                if (ret) {
                    ret = cfdpCRCFlag_IsConstraintValid((&(pVal->crc_flag)), pErrCode);
                    if (ret) {
                        ret = cfdpPDUDataFieldLength_IsConstraintValid((&(pVal->pdu_data_field_length)), pErrCode);
                        if (ret) {
                            ret = cfdpEntityId_IsConstraintValid((&(pVal->source_entity_id)), pErrCode);
                            if (ret) {
                                ret = cfdpTransactionSequenceNumber_IsConstraintValid((&(pVal->transaction_sequence_number)), pErrCode);
                                if (ret) {
                                    ret = cfdpEntityId_IsConstraintValid((&(pVal->destination_entity_id)), pErrCode);
                                }   /*COVERAGE_IGNORE*/
                            }   /*COVERAGE_IGNORE*/
                        }   /*COVERAGE_IGNORE*/
                    }   /*COVERAGE_IGNORE*/
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpPDUHeader cfdpPDUHeader_constant = {.version = 0UL, .pdu_type = PDUType_file_directive, .direction = Direction_toward_receiver, .transmission_mode = TransmissionMode_acknowledged, .crc_flag = CRCFlag_crc_not_present, .pdu_data_field_length = 0UL, .source_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .transaction_sequence_number = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .destination_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}};
#endif

void cfdpPDUHeader_Initialize(cfdpPDUHeader* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUHeader)cfdpPDUHeader_constant;
}

flag cfdpPDUHeader_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpProtocolVersion_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pdu_type */
	        ret = cfdpPDUType_Encode((&(pVal->pdu_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode direction */
	            ret = cfdpDirection_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transmission_mode */
	                ret = cfdpTransmissionMode_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode crc_flag */
	                    ret = cfdpCRCFlag_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode pdu_data_field_length */
	                        ret = cfdpPDUDataFieldLength_Encode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode source_entity_id */
	                            ret = cfdpEntityId_Encode((&(pVal->source_entity_id)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode transaction_sequence_number */
	                                ret = cfdpTransactionSequenceNumber_Encode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode destination_entity_id */
	                                    ret = cfdpEntityId_Encode((&(pVal->destination_entity_id)), pBitStrm, pErrCode, FALSE);
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode version */
	ret = cfdpProtocolVersion_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pdu_type */
	    ret = cfdpPDUType_Decode((&(pVal->pdu_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode direction */
	        ret = cfdpDirection_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transmission_mode */
	            ret = cfdpTransmissionMode_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode crc_flag */
	                ret = cfdpCRCFlag_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode pdu_data_field_length */
	                    ret = cfdpPDUDataFieldLength_Decode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode source_entity_id */
	                        ret = cfdpEntityId_Decode((&(pVal->source_entity_id)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode transaction_sequence_number */
	                            ret = cfdpTransactionSequenceNumber_Decode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode destination_entity_id */
	                                ret = cfdpEntityId_Decode((&(pVal->destination_entity_id)), pBitStrm, pErrCode);
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUHeader_ACN_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint PDUHeader_length_of_entity_ids;
	flag PDUHeader_length_of_entity_ids_is_initialized=FALSE;
	asn1SccUint PDUHeader_length_of_transaction_sequence_number;
	flag PDUHeader_length_of_transaction_sequence_number_is_initialized=FALSE;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpProtocolVersion_ACN_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pdu_type */
	        ret = cfdpPDUType_ACN_Encode((&(pVal->pdu_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode direction */
	            ret = cfdpDirection_ACN_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transmission_mode */
	                ret = cfdpTransmissionMode_ACN_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode crc_flag */
	                    ret = cfdpCRCFlag_ACN_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode PDUHeader_reserved_1 */
	                        {
	                        	static byte tmp[] = {0x80};
	                        	BitStream_AppendBits(pBitStrm, tmp, 1);
	                        }
	                        if (ret) {
	                            /*Encode pdu_data_field_length */
	                            ret = cfdpPDUDataFieldLength_ACN_Encode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode PDUHeader_reserved_2 */
	                                {
	                                	static byte tmp[] = {0x80};
	                                	BitStream_AppendBits(pBitStrm, tmp, 1);
	                                }
	                                if (ret) {
	                                    {
	                                        asn1SccUint PDUHeader_length_of_entity_ids00;
	                                        flag PDUHeader_length_of_entity_ids00_is_initialized=FALSE;
	                                        asn1SccUint PDUHeader_length_of_entity_ids01;
	                                        flag PDUHeader_length_of_entity_ids01_is_initialized=FALSE;

	                                        PDUHeader_length_of_entity_ids00_is_initialized = TRUE;
	                                        PDUHeader_length_of_entity_ids00 = pVal->destination_entity_id.nCount;
	                                        PDUHeader_length_of_entity_ids01_is_initialized = TRUE;
	                                        PDUHeader_length_of_entity_ids01 = pVal->source_entity_id.nCount;

	                                        if (ret) {

	                                            *pErrCode = ERR_ACN_ENCODE_UPDATE_PDUHEADER_LENGTH_OF_ENTITY_IDS;
	                                            if (PDUHeader_length_of_entity_ids00_is_initialized) { /*COVERAGE_IGNORE*/
	                                                PDUHeader_length_of_entity_ids = PDUHeader_length_of_entity_ids00; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else if (PDUHeader_length_of_entity_ids01_is_initialized) { /*COVERAGE_IGNORE*/
	                                                PDUHeader_length_of_entity_ids = PDUHeader_length_of_entity_ids01; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else {
	                                                ret = FALSE; /*COVERAGE_IGNORE*/
	                                            }
	                                            if (ret) {
	                                                ret = (((PDUHeader_length_of_entity_ids00_is_initialized && PDUHeader_length_of_entity_ids == PDUHeader_length_of_entity_ids00) || !PDUHeader_length_of_entity_ids00_is_initialized) && ((PDUHeader_length_of_entity_ids01_is_initialized && PDUHeader_length_of_entity_ids == PDUHeader_length_of_entity_ids01) || !PDUHeader_length_of_entity_ids01_is_initialized));
	                                                PDUHeader_length_of_entity_ids_is_initialized = TRUE;
	                                            }
	                                        }
	                                    }
	                                    if (ret) {
	                                        /*Encode PDUHeader_length_of_entity_ids */
	                                        if (PDUHeader_length_of_entity_ids_is_initialized) {
	                                            ret = TRUE;
	                                            Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, PDUHeader_length_of_entity_ids, 3);
	                                        } else {
	                                            *pErrCode = ERR_ACN_ENCODE_PDUHEADER_LENGTH_OF_ENTITY_IDS_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                        }
	                                    }   /*COVERAGE_IGNORE*/
	                                    if (ret) {
	                                        /*Encode PDUHeader_reserved_3 */
	                                        {
	                                        	static byte tmp[] = {0x80};
	                                        	BitStream_AppendBits(pBitStrm, tmp, 1);
	                                        }
	                                        if (ret) {
	                                            PDUHeader_length_of_transaction_sequence_number_is_initialized = TRUE;
	                                            PDUHeader_length_of_transaction_sequence_number = pVal->transaction_sequence_number.nCount;
	                                            if (ret) {
	                                                /*Encode PDUHeader_length_of_transaction_sequence_number */
	                                                if (PDUHeader_length_of_transaction_sequence_number_is_initialized) {
	                                                    ret = TRUE;
	                                                    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, PDUHeader_length_of_transaction_sequence_number, 3);
	                                                } else {
	                                                    *pErrCode = ERR_ACN_ENCODE_PDUHEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                                }
	                                            }   /*COVERAGE_IGNORE*/
	                                            if (ret) {
	                                                /*Encode source_entity_id */
	                                                ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->source_entity_id.arr, pVal->source_entity_id.nCount);
	                                                if (ret) {
	                                                    /*Encode transaction_sequence_number */
	                                                    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->transaction_sequence_number.arr, pVal->transaction_sequence_number.nCount);
	                                                    if (ret) {
	                                                        /*Encode destination_entity_id */
	                                                        ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->destination_entity_id.arr, pVal->destination_entity_id.nCount);
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_ACN_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint PDUHeader_length_of_entity_ids;
	asn1SccUint PDUHeader_length_of_transaction_sequence_number;

	/*Decode version */
	ret = cfdpProtocolVersion_ACN_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pdu_type */
	    ret = cfdpPDUType_ACN_Decode((&(pVal->pdu_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode direction */
	        ret = cfdpDirection_ACN_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transmission_mode */
	            ret = cfdpTransmissionMode_ACN_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode crc_flag */
	                ret = cfdpCRCFlag_ACN_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode PDUHeader_reserved_1 */
	                    {
	                    	static byte tmp[] = {0x80};
	                        flag bDecodingPatternMatches;
	                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                        ret = ret && bDecodingPatternMatches;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_RESERVED_1;
	                    }

	                    if (ret) {
	                        /*Decode pdu_data_field_length */
	                        ret = cfdpPDUDataFieldLength_ACN_Decode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode PDUHeader_reserved_2 */
	                            {
	                            	static byte tmp[] = {0x80};
	                                flag bDecodingPatternMatches;
	                            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                ret = ret && bDecodingPatternMatches;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_RESERVED_2;
	                            }

	                            if (ret) {
	                                /*Decode PDUHeader_length_of_entity_ids */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(PDUHeader_length_of_entity_ids)), 3);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_LENGTH_OF_ENTITY_IDS;
	                                if (ret) {
	                                    /*Decode PDUHeader_reserved_3 */
	                                    {
	                                    	static byte tmp[] = {0x80};
	                                        flag bDecodingPatternMatches;
	                                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                        ret = ret && bDecodingPatternMatches;
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_RESERVED_3;
	                                    }

	                                    if (ret) {
	                                        /*Decode PDUHeader_length_of_transaction_sequence_number */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(PDUHeader_length_of_transaction_sequence_number)), 3);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER;
	                                        if (ret) {
	                                            /*Decode source_entity_id */
	                                            ret = ((1<=PDUHeader_length_of_entity_ids) && (PDUHeader_length_of_entity_ids<=7));
	                                            if (ret) {
	                                                pVal->source_entity_id.nCount = (int)PDUHeader_length_of_entity_ids;
	                                                ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->source_entity_id.arr, pVal->source_entity_id.nCount);
	                                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_SOURCE_ENTITY_ID;
	                                            }
	                                            if (ret) {
	                                                /*Decode transaction_sequence_number */
	                                                ret = ((1<=PDUHeader_length_of_transaction_sequence_number) && (PDUHeader_length_of_transaction_sequence_number<=7));
	                                                if (ret) {
	                                                    pVal->transaction_sequence_number.nCount = (int)PDUHeader_length_of_transaction_sequence_number;
	                                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->transaction_sequence_number.arr, pVal->transaction_sequence_number.nCount);
	                                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_TRANSACTION_SEQUENCE_NUMBER;
	                                                }
	                                                if (ret) {
	                                                    /*Decode destination_entity_id */
	                                                    ret = ((1<=PDUHeader_length_of_entity_ids) && (PDUHeader_length_of_entity_ids<=7));
	                                                    if (ret) {
	                                                        pVal->destination_entity_id.nCount = (int)PDUHeader_length_of_entity_ids;
	                                                        ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->destination_entity_id.arr, pVal->destination_entity_id.nCount);
	                                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_DESTINATION_ENTITY_ID;
	                                                    }
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}


