/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview.h"



flag cfdpDirectiveCode_Equal(const cfdpDirectiveCode* pVal1, const cfdpDirectiveCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveCode_IsConstraintValid(const cfdpDirectiveCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == DirectiveCode_eof_pdu)) || (((*(pVal)) == DirectiveCode_finished_pdu)))) || (((*(pVal)) == DirectiveCode_ack_pdu)))) || (((*(pVal)) == DirectiveCode_metadata_pdu)))) || (((*(pVal)) == DirectiveCode_nak_pdu)))) || (((*(pVal)) == DirectiveCode_prompt_pdu)))) || (((*(pVal)) == DirectiveCode_keep_alive_pdu)));
    *pErrCode = ret ? 0 :  ERR_DIRECTIVECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveCode cfdpDirectiveCode_constant = DirectiveCode_eof_pdu;
#endif

void cfdpDirectiveCode_Initialize(cfdpDirectiveCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveCode)cfdpDirectiveCode_constant;
}

flag cfdpDirectiveCode_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DirectiveCode_eof_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case DirectiveCode_finished_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case DirectiveCode_ack_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case DirectiveCode_metadata_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case DirectiveCode_nak_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case DirectiveCode_prompt_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case DirectiveCode_keep_alive_pdu:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTIVECODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVECODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DirectiveCode_eof_pdu;
	                break;
	            case 1:
	                (*(pVal)) = DirectiveCode_finished_pdu;
	                break;
	            case 2:
	                (*(pVal)) = DirectiveCode_ack_pdu;
	                break;
	            case 3:
	                (*(pVal)) = DirectiveCode_metadata_pdu;
	                break;
	            case 4:
	                (*(pVal)) = DirectiveCode_nak_pdu;
	                break;
	            case 5:
	                (*(pVal)) = DirectiveCode_prompt_pdu;
	                break;
	            case 6:
	                (*(pVal)) = DirectiveCode_keep_alive_pdu;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTIVECODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DirectiveCode_eof_pdu;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveCode_ACN_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DirectiveCode_eof_pdu:
	            intVal_pVal = 0UL;
	            break;
	        case DirectiveCode_finished_pdu:
	            intVal_pVal = 1UL;
	            break;
	        case DirectiveCode_ack_pdu:
	            intVal_pVal = 2UL;
	            break;
	        case DirectiveCode_metadata_pdu:
	            intVal_pVal = 3UL;
	            break;
	        case DirectiveCode_nak_pdu:
	            intVal_pVal = 4UL;
	            break;
	        case DirectiveCode_prompt_pdu:
	            intVal_pVal = 5UL;
	            break;
	        case DirectiveCode_keep_alive_pdu:
	            intVal_pVal = 6UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTIVECODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_ACN_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVECODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DirectiveCode_eof_pdu;
	            break;
	        case 1:
	            (*(pVal)) = DirectiveCode_finished_pdu;
	            break;
	        case 2:
	            (*(pVal)) = DirectiveCode_ack_pdu;
	            break;
	        case 3:
	            (*(pVal)) = DirectiveCode_metadata_pdu;
	            break;
	        case 4:
	            (*(pVal)) = DirectiveCode_nak_pdu;
	            break;
	        case 5:
	            (*(pVal)) = DirectiveCode_prompt_pdu;
	            break;
	        case 6:
	            (*(pVal)) = DirectiveCode_keep_alive_pdu;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTIVECODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirectiveSubtypeCode_Equal(const cfdpDirectiveSubtypeCode* pVal1, const cfdpDirectiveSubtypeCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveSubtypeCode_IsConstraintValid(const cfdpDirectiveSubtypeCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DirectiveSubtypeCode_ack_others)) || (((*(pVal)) == DirectiveSubtypeCode_ack_finished)));
    *pErrCode = ret ? 0 :  ERR_DIRECTIVESUBTYPECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveSubtypeCode cfdpDirectiveSubtypeCode_constant = DirectiveSubtypeCode_ack_others;
#endif

void cfdpDirectiveSubtypeCode_Initialize(cfdpDirectiveSubtypeCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveSubtypeCode)cfdpDirectiveSubtypeCode_constant;
}

flag cfdpDirectiveSubtypeCode_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DirectiveSubtypeCode_ack_others:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DirectiveSubtypeCode_ack_finished:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTIVESUBTYPECODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DirectiveSubtypeCode_ack_others;
	                break;
	            case 1:
	                (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DirectiveSubtypeCode_ack_others;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveSubtypeCode_ACN_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DirectiveSubtypeCode_ack_others:
	            intVal_pVal = 0UL;
	            break;
	        case DirectiveSubtypeCode_ack_finished:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_ACN_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DirectiveSubtypeCode_ack_others;
	            break;
	        case 1:
	            (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpConditionCode_Equal(const cfdpConditionCode* pVal1, const cfdpConditionCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpConditionCode_IsConstraintValid(const cfdpConditionCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((*(pVal)) == ConditionCode_no_error)) || (((*(pVal)) == ConditionCode_positive_ack_limit_reached)))) || (((*(pVal)) == ConditionCode_keep_alive_limit_reached)))) || (((*(pVal)) == ConditionCode_invalid_transmission_mode)))) || (((*(pVal)) == ConditionCode_filestore_rejection)))) || (((*(pVal)) == ConditionCode_file_checksum_failure)))) || (((*(pVal)) == ConditionCode_file_size_error)))) || (((*(pVal)) == ConditionCode_nak_limit_reached)))) || (((*(pVal)) == ConditionCode_inactivity_detected)))) || (((*(pVal)) == ConditionCode_invalid_file_structure)))) || (((*(pVal)) == ConditionCode_suspend_request_received)))) || (((*(pVal)) == ConditionCode_cancel_request_received)));
    *pErrCode = ret ? 0 :  ERR_CONDITIONCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpConditionCode cfdpConditionCode_constant = ConditionCode_no_error;
#endif

void cfdpConditionCode_Initialize(cfdpConditionCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpConditionCode)cfdpConditionCode_constant;
}

flag cfdpConditionCode_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ConditionCode_no_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 11);
	        	break;
	        case ConditionCode_positive_ack_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 11);
	        	break;
	        case ConditionCode_keep_alive_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 11);
	        	break;
	        case ConditionCode_invalid_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 11);
	        	break;
	        case ConditionCode_filestore_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 11);
	        	break;
	        case ConditionCode_file_checksum_failure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 11);
	        	break;
	        case ConditionCode_file_size_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 11);
	        	break;
	        case ConditionCode_nak_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 11);
	        	break;
	        case ConditionCode_inactivity_detected:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 11);
	        	break;
	        case ConditionCode_invalid_file_structure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 11);
	        	break;
	        case ConditionCode_suspend_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 11);
	        	break;
	        case ConditionCode_cancel_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 11);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONDITIONCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 11);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONDITIONCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ConditionCode_no_error;
	                break;
	            case 1:
	                (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	                break;
	            case 2:
	                (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	                break;
	            case 3:
	                (*(pVal)) = ConditionCode_invalid_transmission_mode;
	                break;
	            case 4:
	                (*(pVal)) = ConditionCode_filestore_rejection;
	                break;
	            case 5:
	                (*(pVal)) = ConditionCode_file_checksum_failure;
	                break;
	            case 6:
	                (*(pVal)) = ConditionCode_file_size_error;
	                break;
	            case 7:
	                (*(pVal)) = ConditionCode_nak_limit_reached;
	                break;
	            case 8:
	                (*(pVal)) = ConditionCode_inactivity_detected;
	                break;
	            case 9:
	                (*(pVal)) = ConditionCode_invalid_file_structure;
	                break;
	            case 10:
	                (*(pVal)) = ConditionCode_suspend_request_received;
	                break;
	            case 11:
	                (*(pVal)) = ConditionCode_cancel_request_received;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONDITIONCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ConditionCode_no_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpConditionCode_ACN_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ConditionCode_no_error:
	            intVal_pVal = 0UL;
	            break;
	        case ConditionCode_positive_ack_limit_reached:
	            intVal_pVal = 1UL;
	            break;
	        case ConditionCode_keep_alive_limit_reached:
	            intVal_pVal = 2UL;
	            break;
	        case ConditionCode_invalid_transmission_mode:
	            intVal_pVal = 3UL;
	            break;
	        case ConditionCode_filestore_rejection:
	            intVal_pVal = 4UL;
	            break;
	        case ConditionCode_file_checksum_failure:
	            intVal_pVal = 5UL;
	            break;
	        case ConditionCode_file_size_error:
	            intVal_pVal = 6UL;
	            break;
	        case ConditionCode_nak_limit_reached:
	            intVal_pVal = 7UL;
	            break;
	        case ConditionCode_inactivity_detected:
	            intVal_pVal = 8UL;
	            break;
	        case ConditionCode_invalid_file_structure:
	            intVal_pVal = 9UL;
	            break;
	        case ConditionCode_suspend_request_received:
	            intVal_pVal = 10UL;
	            break;
	        case ConditionCode_cancel_request_received:
	            intVal_pVal = 11UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_ACN_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONDITIONCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ConditionCode_no_error;
	            break;
	        case 1:
	            (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	            break;
	        case 2:
	            (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	            break;
	        case 3:
	            (*(pVal)) = ConditionCode_invalid_transmission_mode;
	            break;
	        case 4:
	            (*(pVal)) = ConditionCode_filestore_rejection;
	            break;
	        case 5:
	            (*(pVal)) = ConditionCode_file_checksum_failure;
	            break;
	        case 6:
	            (*(pVal)) = ConditionCode_file_size_error;
	            break;
	        case 7:
	            (*(pVal)) = ConditionCode_nak_limit_reached;
	            break;
	        case 8:
	            (*(pVal)) = ConditionCode_inactivity_detected;
	            break;
	        case 9:
	            (*(pVal)) = ConditionCode_invalid_file_structure;
	            break;
	        case 10:
	            (*(pVal)) = ConditionCode_suspend_request_received;
	            break;
	        case 11:
	            (*(pVal)) = ConditionCode_cancel_request_received;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileChecksum_Equal(const cfdpFileChecksum* pVal1, const cfdpFileChecksum* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 4) ==0;

}

flag cfdpFileChecksum_IsConstraintValid(const cfdpFileChecksum* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

#ifdef __cplusplus
const cfdpFileChecksum cfdpFileChecksum_constant = {.arr  = {[0 ... 4-1] = 0 }};
#endif

void cfdpFileChecksum_Initialize(cfdpFileChecksum* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileChecksum)cfdpFileChecksum_constant;
}

flag cfdpFileChecksum_Encode(const cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 4);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileChecksum_Decode(cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 4);

	return ret  && cfdpFileChecksum_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileChecksum_ACN_Encode(const cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, 4);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileChecksum_ACN_Decode(cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, 4);

    return ret && cfdpFileChecksum_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileSize_Equal(const cfdpFileSize* pVal1, const cfdpFileSize* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileSize_IsConstraintValid(const cfdpFileSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_FILESIZE;

	return ret;
}

#ifdef __cplusplus
const cfdpFileSize cfdpFileSize_constant = 0UL;
#endif

void cfdpFileSize_Initialize(cfdpFileSize* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileSize)cfdpFileSize_constant;
}

flag cfdpFileSize_Encode(const cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileSize_Decode(cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILESIZE;

	return ret  && cfdpFileSize_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileSize_ACN_Encode(const cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileSize_ACN_Decode(cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILESIZE;

    return ret && cfdpFileSize_IsConstraintValid(pVal, pErrCode);
}


flag cfdpEofPDU_Equal(const cfdpEofPDU* pVal1, const cfdpEofPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->condition_code == pVal2->condition_code);

    if (ret) {
        ret = cfdpFileChecksum_Equal((&(pVal1->file_checksum)), (&(pVal2->file_checksum)));

        if (ret) {
            ret = (pVal1->file_size == pVal2->file_size);

        }

    }

	return ret;

}

flag cfdpEofPDU_IsConstraintValid(const cfdpEofPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
    if (ret) {
        ret = cfdpFileChecksum_IsConstraintValid((&(pVal->file_checksum)), pErrCode);
        if (ret) {
            ret = cfdpFileSize_IsConstraintValid((&(pVal->file_size)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpEofPDU cfdpEofPDU_constant = {.condition_code = ConditionCode_no_error, .file_checksum = {.arr  = {[0 ... 4-1] = 0 }}, .file_size = 0UL};
#endif

void cfdpEofPDU_Initialize(cfdpEofPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpEofPDU)cfdpEofPDU_constant;
}

flag cfdpEofPDU_Encode(const cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpEofPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode file_checksum */
	        ret = cfdpFileChecksum_Encode((&(pVal->file_checksum)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_size */
	            ret = cfdpFileSize_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEofPDU_Decode(cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode file_checksum */
	    ret = cfdpFileChecksum_Decode((&(pVal->file_checksum)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_size */
	        ret = cfdpFileSize_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpEofPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpEofPDU_ACN_Encode(const cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpEofPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_ACN_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode EofPDU_spare */
	        {
	        	static byte tmp[] = {0x00};
	        	BitStream_AppendBits(pBitStrm, tmp, 4);
	        }
	        if (ret) {
	            /*Encode file_checksum */
	            ret = cfdpFileChecksum_ACN_Encode((&(pVal->file_checksum)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode file_size */
	                ret = cfdpFileSize_ACN_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEofPDU_ACN_Decode(cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_ACN_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode EofPDU_spare */
	    {
	    	static byte tmp[] = {0x00};
	        flag bDecodingPatternMatches;
	    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 4, &bDecodingPatternMatches);
	        ret = ret && bDecodingPatternMatches;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_EOFPDU_SPARE;
	    }

	    if (ret) {
	        /*Decode file_checksum */
	        ret = cfdpFileChecksum_ACN_Decode((&(pVal->file_checksum)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode file_size */
	            ret = cfdpFileSize_ACN_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpEofPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpAckTransactionStatus_Equal(const cfdpAckTransactionStatus* pVal1, const cfdpAckTransactionStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpAckTransactionStatus_IsConstraintValid(const cfdpAckTransactionStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == AckTransactionStatus_undefined)) || (((*(pVal)) == AckTransactionStatus_active)))) || (((*(pVal)) == AckTransactionStatus_terminated)))) || (((*(pVal)) == AckTransactionStatus_unrecognized)));
    *pErrCode = ret ? 0 :  ERR_ACKTRANSACTIONSTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpAckTransactionStatus cfdpAckTransactionStatus_constant = AckTransactionStatus_undefined;
#endif

void cfdpAckTransactionStatus_Initialize(cfdpAckTransactionStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpAckTransactionStatus)cfdpAckTransactionStatus_constant;
}

flag cfdpAckTransactionStatus_Encode(const cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case AckTransactionStatus_undefined:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case AckTransactionStatus_active:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case AckTransactionStatus_terminated:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case AckTransactionStatus_unrecognized:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACKTRANSACTIONSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckTransactionStatus_Decode(cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACKTRANSACTIONSTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = AckTransactionStatus_undefined;
	                break;
	            case 1:
	                (*(pVal)) = AckTransactionStatus_active;
	                break;
	            case 2:
	                (*(pVal)) = AckTransactionStatus_terminated;
	                break;
	            case 3:
	                (*(pVal)) = AckTransactionStatus_unrecognized;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACKTRANSACTIONSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = AckTransactionStatus_undefined;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpAckTransactionStatus_ACN_Encode(const cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case AckTransactionStatus_undefined:
	            intVal_pVal = 0UL;
	            break;
	        case AckTransactionStatus_active:
	            intVal_pVal = 1UL;
	            break;
	        case AckTransactionStatus_terminated:
	            intVal_pVal = 2UL;
	            break;
	        case AckTransactionStatus_unrecognized:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACKTRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckTransactionStatus_ACN_Decode(cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKTRANSACTIONSTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = AckTransactionStatus_undefined;
	            break;
	        case 1:
	            (*(pVal)) = AckTransactionStatus_active;
	            break;
	        case 2:
	            (*(pVal)) = AckTransactionStatus_terminated;
	            break;
	        case 3:
	            (*(pVal)) = AckTransactionStatus_unrecognized;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACKTRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpAckPDU_Equal(const cfdpAckPDU* pVal1, const cfdpAckPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->directive_code_of_ack_pdu == pVal2->directive_code_of_ack_pdu);

    if (ret) {
        ret = (pVal1->directive_subtype_code == pVal2->directive_subtype_code);

        if (ret) {
            ret = (pVal1->condition_code == pVal2->condition_code);

            if (ret) {
                ret = (pVal1->transaction_status == pVal2->transaction_status);

            }

        }

    }

	return ret;

}

flag cfdpAckPDU_IsConstraintValid(const cfdpAckPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpDirectiveCode_IsConstraintValid((&(pVal->directive_code_of_ack_pdu)), pErrCode);
    if (ret) {
        ret = cfdpDirectiveSubtypeCode_IsConstraintValid((&(pVal->directive_subtype_code)), pErrCode);
        if (ret) {
            ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
            if (ret) {
                ret = cfdpAckTransactionStatus_IsConstraintValid((&(pVal->transaction_status)), pErrCode);
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpAckPDU cfdpAckPDU_constant = {.directive_code_of_ack_pdu = DirectiveCode_eof_pdu, .directive_subtype_code = DirectiveSubtypeCode_ack_others, .condition_code = ConditionCode_no_error, .transaction_status = AckTransactionStatus_undefined};
#endif

void cfdpAckPDU_Initialize(cfdpAckPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpAckPDU)cfdpAckPDU_constant;
}

flag cfdpAckPDU_Encode(const cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode directive_code_of_ack_pdu */
	    ret = cfdpDirectiveCode_Encode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode directive_subtype_code */
	        ret = cfdpDirectiveSubtypeCode_Encode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode condition_code */
	            ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transaction_status */
	                ret = cfdpAckTransactionStatus_Encode((&(pVal->transaction_status)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckPDU_Decode(cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode directive_code_of_ack_pdu */
	ret = cfdpDirectiveCode_Decode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode directive_subtype_code */
	    ret = cfdpDirectiveSubtypeCode_Decode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode condition_code */
	        ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transaction_status */
	            ret = cfdpAckTransactionStatus_Decode((&(pVal->transaction_status)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpAckPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpAckPDU_ACN_Encode(const cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode directive_code_of_ack_pdu */
	    ret = cfdpDirectiveCode_ACN_Encode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode directive_subtype_code */
	        ret = cfdpDirectiveSubtypeCode_ACN_Encode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode condition_code */
	            ret = cfdpConditionCode_ACN_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode AckPDU_spare */
	                {
	                	static byte tmp[] = {0x00};
	                	BitStream_AppendBits(pBitStrm, tmp, 2);
	                }
	                if (ret) {
	                    /*Encode transaction_status */
	                    ret = cfdpAckTransactionStatus_ACN_Encode((&(pVal->transaction_status)), pBitStrm, pErrCode, FALSE);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckPDU_ACN_Decode(cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode directive_code_of_ack_pdu */
	ret = cfdpDirectiveCode_ACN_Decode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode directive_subtype_code */
	    ret = cfdpDirectiveSubtypeCode_ACN_Decode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode condition_code */
	        ret = cfdpConditionCode_ACN_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode AckPDU_spare */
	            {
	            	static byte tmp[] = {0x00};
	                flag bDecodingPatternMatches;
	            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                ret = ret && bDecodingPatternMatches;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_SPARE;
	            }

	            if (ret) {
	                /*Decode transaction_status */
	                ret = cfdpAckTransactionStatus_ACN_Decode((&(pVal->transaction_status)), pBitStrm, pErrCode);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpAckPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDeliveryCode_Equal(const cfdpDeliveryCode* pVal1, const cfdpDeliveryCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDeliveryCode_IsConstraintValid(const cfdpDeliveryCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DeliveryCode_data_complete)) || (((*(pVal)) == DeliveryCode_data_incomplete)));
    *pErrCode = ret ? 0 :  ERR_DELIVERYCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDeliveryCode cfdpDeliveryCode_constant = DeliveryCode_data_complete;
#endif

void cfdpDeliveryCode_Initialize(cfdpDeliveryCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDeliveryCode)cfdpDeliveryCode_constant;
}

flag cfdpDeliveryCode_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DeliveryCode_data_complete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DeliveryCode_data_incomplete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DELIVERYCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DELIVERYCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DeliveryCode_data_complete;
	                break;
	            case 1:
	                (*(pVal)) = DeliveryCode_data_incomplete;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DELIVERYCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DeliveryCode_data_complete;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDeliveryCode_ACN_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DeliveryCode_data_complete:
	            intVal_pVal = 0UL;
	            break;
	        case DeliveryCode_data_incomplete:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_ACN_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DELIVERYCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DeliveryCode_data_complete;
	            break;
	        case 1:
	            (*(pVal)) = DeliveryCode_data_incomplete;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpClosureRequested_Equal(const cfdpClosureRequested* pVal1, const cfdpClosureRequested* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpClosureRequested_IsConstraintValid(const cfdpClosureRequested* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == ClosureRequested_requested)) || (((*(pVal)) == ClosureRequested_not_requested)));
    *pErrCode = ret ? 0 :  ERR_CLOSUREREQUESTED;

	return ret;
}

#ifdef __cplusplus
const cfdpClosureRequested cfdpClosureRequested_constant = ClosureRequested_requested;
#endif

void cfdpClosureRequested_Initialize(cfdpClosureRequested* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpClosureRequested)cfdpClosureRequested_constant;
}

flag cfdpClosureRequested_Encode(const cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpClosureRequested_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ClosureRequested_requested:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case ClosureRequested_not_requested:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CLOSUREREQUESTED; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpClosureRequested_Decode(cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CLOSUREREQUESTED;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ClosureRequested_requested;
	                break;
	            case 1:
	                (*(pVal)) = ClosureRequested_not_requested;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CLOSUREREQUESTED;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ClosureRequested_requested;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpClosureRequested_IsConstraintValid(pVal, pErrCode);
}

flag cfdpClosureRequested_ACN_Encode(const cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpClosureRequested_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ClosureRequested_requested:
	            intVal_pVal = 0UL;
	            break;
	        case ClosureRequested_not_requested:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CLOSUREREQUESTED;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpClosureRequested_ACN_Decode(cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CLOSUREREQUESTED;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ClosureRequested_requested;
	            break;
	        case 1:
	            (*(pVal)) = ClosureRequested_not_requested;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CLOSUREREQUESTED;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpClosureRequested_IsConstraintValid(pVal, pErrCode);
}


flag cfdpChecksumType_Equal(const cfdpChecksumType* pVal1, const cfdpChecksumType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpChecksumType_IsConstraintValid(const cfdpChecksumType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 15UL);
    *pErrCode = ret ? 0 :  ERR_CHECKSUMTYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpChecksumType cfdpChecksumType_constant = 0UL;
#endif

void cfdpChecksumType_Initialize(cfdpChecksumType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpChecksumType)cfdpChecksumType_constant;
}

flag cfdpChecksumType_Encode(const cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpChecksumType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 15);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpChecksumType_Decode(cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 15);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_CHECKSUMTYPE;

	return ret  && cfdpChecksumType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpChecksumType_ACN_Encode(const cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpChecksumType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 4);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpChecksumType_ACN_Decode(cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CHECKSUMTYPE;

    return ret && cfdpChecksumType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileNameSize_Equal(const cfdpFileNameSize* pVal1, const cfdpFileNameSize* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileNameSize_IsConstraintValid(const cfdpFileNameSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 254UL);
    *pErrCode = ret ? 0 :  ERR_FILENAMESIZE;

	return ret;
}

#ifdef __cplusplus
const cfdpFileNameSize cfdpFileNameSize_constant = 0UL;
#endif

void cfdpFileNameSize_Initialize(cfdpFileNameSize* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileNameSize)cfdpFileNameSize_constant;
}

flag cfdpFileNameSize_Encode(const cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileNameSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 254);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileNameSize_Decode(cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 254);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILENAMESIZE;

	return ret  && cfdpFileNameSize_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileNameSize_ACN_Encode(const cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileNameSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileNameSize_ACN_Decode(cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILENAMESIZE;

    return ret && cfdpFileNameSize_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileName_Equal(const cfdpFileName* pVal1, const cfdpFileName* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpFileName_IsConstraintValid(const cfdpFileName* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 254);
    *pErrCode = ret ? 0 :  ERR_FILENAME;

	return ret;
}

#ifdef __cplusplus
const cfdpFileName cfdpFileName_constant = {.nCount = 0, .arr  = {[0 ... 254-1] = 0 }};
#endif

void cfdpFileName_Initialize(cfdpFileName* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileName)cfdpFileName_constant;
}

flag cfdpFileName_Encode(const cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 254);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileName_Decode(cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 254);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILENAME;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpFileName_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileName_ACN_Encode(const cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 254);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileName_ACN_Decode(cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 254);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILENAME;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpFileName_IsConstraintValid(pVal, pErrCode);
}


flag cfdpMetadataPDU_Equal(const cfdpMetadataPDU* pVal1, const cfdpMetadataPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->closure_requested == pVal2->closure_requested);

    if (ret) {
        ret = (pVal1->checksum_type == pVal2->checksum_type);

        if (ret) {
            ret = (pVal1->file_size == pVal2->file_size);

            if (ret) {
                ret = cfdpFileName_Equal((&(pVal1->source_file_name)), (&(pVal2->source_file_name)));

                if (ret) {
                    ret = cfdpFileName_Equal((&(pVal1->destination_file_name)), (&(pVal2->destination_file_name)));

                }

            }

        }

    }

	return ret;

}

flag cfdpMetadataPDU_IsConstraintValid(const cfdpMetadataPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpClosureRequested_IsConstraintValid((&(pVal->closure_requested)), pErrCode);
    if (ret) {
        ret = cfdpChecksumType_IsConstraintValid((&(pVal->checksum_type)), pErrCode);
        if (ret) {
            ret = cfdpFileSize_IsConstraintValid((&(pVal->file_size)), pErrCode);
            if (ret) {
                ret = cfdpFileName_IsConstraintValid((&(pVal->source_file_name)), pErrCode);
                if (ret) {
                    ret = cfdpFileName_IsConstraintValid((&(pVal->destination_file_name)), pErrCode);
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpMetadataPDU cfdpMetadataPDU_constant = {.closure_requested = ClosureRequested_requested, .checksum_type = 0UL, .file_size = 0UL, .source_file_name = {.nCount = 0, .arr  = {[0 ... 254-1] = 0 }}, .destination_file_name = {.nCount = 0, .arr  = {[0 ... 254-1] = 0 }}};
#endif

void cfdpMetadataPDU_Initialize(cfdpMetadataPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpMetadataPDU)cfdpMetadataPDU_constant;
}

flag cfdpMetadataPDU_Encode(const cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode closure_requested */
	    ret = cfdpClosureRequested_Encode((&(pVal->closure_requested)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode checksum_type */
	        ret = cfdpChecksumType_Encode((&(pVal->checksum_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_size */
	            ret = cfdpFileSize_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode source_file_name */
	                ret = cfdpFileName_Encode((&(pVal->source_file_name)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode destination_file_name */
	                    ret = cfdpFileName_Encode((&(pVal->destination_file_name)), pBitStrm, pErrCode, FALSE);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMetadataPDU_Decode(cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode closure_requested */
	ret = cfdpClosureRequested_Decode((&(pVal->closure_requested)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode checksum_type */
	    ret = cfdpChecksumType_Decode((&(pVal->checksum_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_size */
	        ret = cfdpFileSize_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode source_file_name */
	            ret = cfdpFileName_Decode((&(pVal->source_file_name)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode destination_file_name */
	                ret = cfdpFileName_Decode((&(pVal->destination_file_name)), pBitStrm, pErrCode);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpMetadataPDU_ACN_Encode(const cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint MetadataPDU_source_file_name_size;
	flag MetadataPDU_source_file_name_size_is_initialized=FALSE;
	asn1SccUint MetadataPDU_destination_file_name_size;
	flag MetadataPDU_destination_file_name_size_is_initialized=FALSE;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode MetadataPDU_reserved1 */
	    {
	    	static byte tmp[] = {0x00};
	    	BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
	    if (ret) {
	        /*Encode closure_requested */
	        ret = cfdpClosureRequested_ACN_Encode((&(pVal->closure_requested)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode MetadataPDU_reserved2 */
	            {
	            	static byte tmp[] = {0x00};
	            	BitStream_AppendBits(pBitStrm, tmp, 2);
	            }
	            if (ret) {
	                /*Encode checksum_type */
	                ret = cfdpChecksumType_ACN_Encode((&(pVal->checksum_type)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode file_size */
	                    ret = cfdpFileSize_ACN_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        MetadataPDU_source_file_name_size_is_initialized = TRUE;
	                        MetadataPDU_source_file_name_size = pVal->source_file_name.nCount;
	                        if (ret) {
	                            /*Encode MetadataPDU_source_file_name_size */
	                            if (MetadataPDU_source_file_name_size_is_initialized) {
	                                ret = TRUE;
	                                Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, MetadataPDU_source_file_name_size);
	                            } else {
	                                *pErrCode = ERR_ACN_ENCODE_METADATAPDU_SOURCE_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                ret = FALSE;                    /*COVERAGE_IGNORE*/
	                            }
	                        }   /*COVERAGE_IGNORE*/
	                        if (ret) {
	                            /*Encode source_file_name */
	                            ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->source_file_name.arr, pVal->source_file_name.nCount);
	                            if (ret) {
	                                MetadataPDU_destination_file_name_size_is_initialized = TRUE;
	                                MetadataPDU_destination_file_name_size = pVal->destination_file_name.nCount;
	                                if (ret) {
	                                    /*Encode MetadataPDU_destination_file_name_size */
	                                    if (MetadataPDU_destination_file_name_size_is_initialized) {
	                                        ret = TRUE;
	                                        Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, MetadataPDU_destination_file_name_size);
	                                    } else {
	                                        *pErrCode = ERR_ACN_ENCODE_METADATAPDU_DESTINATION_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                        ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                    }
	                                }   /*COVERAGE_IGNORE*/
	                                if (ret) {
	                                    /*Encode destination_file_name */
	                                    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->destination_file_name.arr, pVal->destination_file_name.nCount);
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMetadataPDU_ACN_Decode(cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint MetadataPDU_source_file_name_size;
	asn1SccUint MetadataPDU_destination_file_name_size;

	/*Decode MetadataPDU_reserved1 */
	{
		static byte tmp[] = {0x00};
	    flag bDecodingPatternMatches;
		ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	    ret = ret && bDecodingPatternMatches;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_RESERVED1;
	}

	if (ret) {
	    /*Decode closure_requested */
	    ret = cfdpClosureRequested_ACN_Decode((&(pVal->closure_requested)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode MetadataPDU_reserved2 */
	        {
	        	static byte tmp[] = {0x00};
	            flag bDecodingPatternMatches;
	        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	            ret = ret && bDecodingPatternMatches;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_RESERVED2;
	        }

	        if (ret) {
	            /*Decode checksum_type */
	            ret = cfdpChecksumType_ACN_Decode((&(pVal->checksum_type)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode file_size */
	                ret = cfdpFileSize_ACN_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode MetadataPDU_source_file_name_size */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(MetadataPDU_source_file_name_size)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_SOURCE_FILE_NAME_SIZE;
	                    if (ret) {
	                        /*Decode source_file_name */
	                        ret = ((MetadataPDU_source_file_name_size<=254));
	                        if (ret) {
	                            pVal->source_file_name.nCount = (int)MetadataPDU_source_file_name_size;
	                            ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->source_file_name.arr, pVal->source_file_name.nCount);
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_SOURCE_FILE_NAME;
	                        }
	                        if (ret) {
	                            /*Decode MetadataPDU_destination_file_name_size */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(MetadataPDU_destination_file_name_size)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_DESTINATION_FILE_NAME_SIZE;
	                            if (ret) {
	                                /*Decode destination_file_name */
	                                ret = ((MetadataPDU_destination_file_name_size<=254));
	                                if (ret) {
	                                    pVal->destination_file_name.nCount = (int)MetadataPDU_destination_file_name_size;
	                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->destination_file_name.arr, pVal->destination_file_name.nCount);
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_DESTINATION_FILE_NAME;
	                                }
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileStatus_Equal(const cfdpFileStatus* pVal1, const cfdpFileStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileStatus_IsConstraintValid(const cfdpFileStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == FileStatus_discarted_deliberately)) || (((*(pVal)) == FileStatus_discarted_file_rejection)))) || (((*(pVal)) == FileStatus_retained_successfully)))) || (((*(pVal)) == FileStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_FILESTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpFileStatus cfdpFileStatus_constant = FileStatus_discarted_deliberately;
#endif

void cfdpFileStatus_Initialize(cfdpFileStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileStatus)cfdpFileStatus_constant;
}

flag cfdpFileStatus_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case FileStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case FileStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case FileStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case FileStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_FILESTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_FILESTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = FileStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = FileStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = FileStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = FileStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_FILESTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = FileStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileStatus_ACN_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case FileStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case FileStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case FileStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case FileStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_ACN_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILESTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = FileStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = FileStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = FileStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = FileStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFinishedPDU_Equal(const cfdpFinishedPDU* pVal1, const cfdpFinishedPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->condition_code == pVal2->condition_code);

    if (ret) {
        ret = (pVal1->delivery_code == pVal2->delivery_code);

        if (ret) {
            ret = (pVal1->file_status == pVal2->file_status);

        }

    }

	return ret;

}

flag cfdpFinishedPDU_IsConstraintValid(const cfdpFinishedPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
    if (ret) {
        ret = cfdpDeliveryCode_IsConstraintValid((&(pVal->delivery_code)), pErrCode);
        if (ret) {
            ret = cfdpFileStatus_IsConstraintValid((&(pVal->file_status)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpFinishedPDU cfdpFinishedPDU_constant = {.condition_code = ConditionCode_no_error, .delivery_code = DeliveryCode_data_complete, .file_status = FileStatus_discarted_deliberately};
#endif

void cfdpFinishedPDU_Initialize(cfdpFinishedPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFinishedPDU)cfdpFinishedPDU_constant;
}

flag cfdpFinishedPDU_Encode(const cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode delivery_code */
	        ret = cfdpDeliveryCode_Encode((&(pVal->delivery_code)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_status */
	            ret = cfdpFileStatus_Encode((&(pVal->file_status)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFinishedPDU_Decode(cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode delivery_code */
	    ret = cfdpDeliveryCode_Decode((&(pVal->delivery_code)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_status */
	        ret = cfdpFileStatus_Decode((&(pVal->file_status)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFinishedPDU_ACN_Encode(const cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_ACN_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode FinishedPDU_end_system_status */
	        {
	        	static byte tmp[] = {0x80};
	        	BitStream_AppendBits(pBitStrm, tmp, 1);
	        }
	        if (ret) {
	            /*Encode delivery_code */
	            ret = cfdpDeliveryCode_ACN_Encode((&(pVal->delivery_code)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode file_status */
	                ret = cfdpFileStatus_ACN_Encode((&(pVal->file_status)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFinishedPDU_ACN_Decode(cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_ACN_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode FinishedPDU_end_system_status */
	    {
	    	static byte tmp[] = {0x80};
	        flag bDecodingPatternMatches;
	    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	        ret = ret && bDecodingPatternMatches;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FINISHEDPDU_END_SYSTEM_STATUS;
	    }

	    if (ret) {
	        /*Decode delivery_code */
	        ret = cfdpDeliveryCode_ACN_Decode((&(pVal->delivery_code)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode file_status */
	            ret = cfdpFileStatus_ACN_Decode((&(pVal->file_status)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionStatus_Equal(const cfdpTransactionStatus* pVal1, const cfdpTransactionStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransactionStatus_IsConstraintValid(const cfdpTransactionStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == TransactionStatus_discarted_deliberately)) || (((*(pVal)) == TransactionStatus_discarted_file_rejection)))) || (((*(pVal)) == TransactionStatus_retained_successfully)))) || (((*(pVal)) == TransactionStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionStatus cfdpTransactionStatus_constant = TransactionStatus_discarted_deliberately;
#endif

void cfdpTransactionStatus_Initialize(cfdpTransactionStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionStatus)cfdpTransactionStatus_constant;
}

flag cfdpTransactionStatus_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransactionStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case TransactionStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case TransactionStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case TransactionStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSACTIONSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransactionStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = TransactionStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = TransactionStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = TransactionStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSACTIONSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransactionStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionStatus_ACN_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransactionStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case TransactionStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case TransactionStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case TransactionStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_ACN_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransactionStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = TransactionStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = TransactionStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = TransactionStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTypeFieldCode_Equal(const cfdpTypeFieldCode* pVal1, const cfdpTypeFieldCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTypeFieldCode_IsConstraintValid(const cfdpTypeFieldCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == TypeFieldCode_filestore_request)) || (((*(pVal)) == TypeFieldCode_filestore_response)))) || (((*(pVal)) == TypeFieldCode_message_to_user)))) || (((*(pVal)) == TypeFieldCode_fault_handler_overrides)))) || (((*(pVal)) == TypeFieldCode_flow_label)))) || (((*(pVal)) == TypeFieldCode_entity_id)));
    *pErrCode = ret ? 0 :  ERR_TYPEFIELDCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTypeFieldCode cfdpTypeFieldCode_constant = TypeFieldCode_filestore_request;
#endif

void cfdpTypeFieldCode_Initialize(cfdpTypeFieldCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTypeFieldCode)cfdpTypeFieldCode_constant;
}

flag cfdpTypeFieldCode_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TypeFieldCode_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case TypeFieldCode_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case TypeFieldCode_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case TypeFieldCode_fault_handler_overrides:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case TypeFieldCode_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case TypeFieldCode_entity_id:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TYPEFIELDCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TYPEFIELDCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TypeFieldCode_filestore_request;
	                break;
	            case 1:
	                (*(pVal)) = TypeFieldCode_filestore_response;
	                break;
	            case 2:
	                (*(pVal)) = TypeFieldCode_message_to_user;
	                break;
	            case 3:
	                (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	                break;
	            case 4:
	                (*(pVal)) = TypeFieldCode_flow_label;
	                break;
	            case 5:
	                (*(pVal)) = TypeFieldCode_entity_id;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TYPEFIELDCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TypeFieldCode_filestore_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTypeFieldCode_ACN_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TypeFieldCode_filestore_request:
	            intVal_pVal = 0UL;
	            break;
	        case TypeFieldCode_filestore_response:
	            intVal_pVal = 1UL;
	            break;
	        case TypeFieldCode_message_to_user:
	            intVal_pVal = 2UL;
	            break;
	        case TypeFieldCode_fault_handler_overrides:
	            intVal_pVal = 3UL;
	            break;
	        case TypeFieldCode_flow_label:
	            intVal_pVal = 4UL;
	            break;
	        case TypeFieldCode_entity_id:
	            intVal_pVal = 5UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_ACN_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TYPEFIELDCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TypeFieldCode_filestore_request;
	            break;
	        case 1:
	            (*(pVal)) = TypeFieldCode_filestore_response;
	            break;
	        case 2:
	            (*(pVal)) = TypeFieldCode_message_to_user;
	            break;
	        case 3:
	            (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	            break;
	        case 4:
	            (*(pVal)) = TypeFieldCode_flow_label;
	            break;
	        case 5:
	            (*(pVal)) = TypeFieldCode_entity_id;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpMessageType_Equal(const cfdpMessageType* pVal1, const cfdpMessageType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpMessageType_IsConstraintValid(const cfdpMessageType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((((((*(pVal)) == MessageType_proxy_put_request)) || (((*(pVal)) == MessageType_proxy_message_to_user)))) || (((*(pVal)) == MessageType_proxy_filestore_request)))) || (((*(pVal)) == MessageType_proxy_fault_handler_override)))) || (((*(pVal)) == MessageType_proxy_transmission_mode)))) || (((*(pVal)) == MessageType_proxy_flow_label)))) || (((*(pVal)) == MessageType_proxy_segmentation_control)))) || (((*(pVal)) == MessageType_proxy_put_response)))) || (((*(pVal)) == MessageType_proxy_filestore_response)))) || (((*(pVal)) == MessageType_proxy_put_cancel)))) || (((*(pVal)) == MessageType_directory_listing_request)))) || (((*(pVal)) == MessageType_directory_listing_response)))) || (((*(pVal)) == MessageType_remote_status_report_request)))) || (((*(pVal)) == MessageType_remote_status_report_response)))) || (((*(pVal)) == MessageType_remote_suspend_request)))) || (((*(pVal)) == MessageType_remote_suspend_response)))) || (((*(pVal)) == MessageType_remote_resume_request)))) || (((*(pVal)) == MessageType_remote_resume_response)));
    *pErrCode = ret ? 0 :  ERR_MESSAGETYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpMessageType cfdpMessageType_constant = MessageType_proxy_put_request;
#endif

void cfdpMessageType_Initialize(cfdpMessageType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpMessageType)cfdpMessageType_constant;
}

flag cfdpMessageType_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case MessageType_proxy_put_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 17);
	        	break;
	        case MessageType_proxy_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 17);
	        	break;
	        case MessageType_proxy_fault_handler_override:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 17);
	        	break;
	        case MessageType_proxy_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 17);
	        	break;
	        case MessageType_proxy_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 17);
	        	break;
	        case MessageType_proxy_segmentation_control:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 17);
	        	break;
	        case MessageType_proxy_put_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 17);
	        	break;
	        case MessageType_proxy_put_cancel:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 17);
	        	break;
	        case MessageType_directory_listing_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 17);
	        	break;
	        case MessageType_directory_listing_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 17);
	        	break;
	        case MessageType_remote_status_report_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 17);
	        	break;
	        case MessageType_remote_status_report_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 17);
	        	break;
	        case MessageType_remote_suspend_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 17);
	        	break;
	        case MessageType_remote_suspend_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 17);
	        	break;
	        case MessageType_remote_resume_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 16, 0, 17);
	        	break;
	        case MessageType_remote_resume_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 17, 0, 17);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MESSAGETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 17);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MESSAGETYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = MessageType_proxy_put_request;
	                break;
	            case 1:
	                (*(pVal)) = MessageType_proxy_message_to_user;
	                break;
	            case 2:
	                (*(pVal)) = MessageType_proxy_filestore_request;
	                break;
	            case 3:
	                (*(pVal)) = MessageType_proxy_fault_handler_override;
	                break;
	            case 4:
	                (*(pVal)) = MessageType_proxy_transmission_mode;
	                break;
	            case 5:
	                (*(pVal)) = MessageType_proxy_flow_label;
	                break;
	            case 6:
	                (*(pVal)) = MessageType_proxy_segmentation_control;
	                break;
	            case 7:
	                (*(pVal)) = MessageType_proxy_put_response;
	                break;
	            case 8:
	                (*(pVal)) = MessageType_proxy_filestore_response;
	                break;
	            case 9:
	                (*(pVal)) = MessageType_proxy_put_cancel;
	                break;
	            case 10:
	                (*(pVal)) = MessageType_directory_listing_request;
	                break;
	            case 11:
	                (*(pVal)) = MessageType_directory_listing_response;
	                break;
	            case 12:
	                (*(pVal)) = MessageType_remote_status_report_request;
	                break;
	            case 13:
	                (*(pVal)) = MessageType_remote_status_report_response;
	                break;
	            case 14:
	                (*(pVal)) = MessageType_remote_suspend_request;
	                break;
	            case 15:
	                (*(pVal)) = MessageType_remote_suspend_response;
	                break;
	            case 16:
	                (*(pVal)) = MessageType_remote_resume_request;
	                break;
	            case 17:
	                (*(pVal)) = MessageType_remote_resume_response;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MESSAGETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = MessageType_proxy_put_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpMessageType_ACN_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case MessageType_proxy_put_request:
	            intVal_pVal = 0UL;
	            break;
	        case MessageType_proxy_message_to_user:
	            intVal_pVal = 1UL;
	            break;
	        case MessageType_proxy_filestore_request:
	            intVal_pVal = 2UL;
	            break;
	        case MessageType_proxy_fault_handler_override:
	            intVal_pVal = 3UL;
	            break;
	        case MessageType_proxy_transmission_mode:
	            intVal_pVal = 4UL;
	            break;
	        case MessageType_proxy_flow_label:
	            intVal_pVal = 5UL;
	            break;
	        case MessageType_proxy_segmentation_control:
	            intVal_pVal = 6UL;
	            break;
	        case MessageType_proxy_put_response:
	            intVal_pVal = 7UL;
	            break;
	        case MessageType_proxy_filestore_response:
	            intVal_pVal = 8UL;
	            break;
	        case MessageType_proxy_put_cancel:
	            intVal_pVal = 9UL;
	            break;
	        case MessageType_directory_listing_request:
	            intVal_pVal = 10UL;
	            break;
	        case MessageType_directory_listing_response:
	            intVal_pVal = 11UL;
	            break;
	        case MessageType_remote_status_report_request:
	            intVal_pVal = 12UL;
	            break;
	        case MessageType_remote_status_report_response:
	            intVal_pVal = 13UL;
	            break;
	        case MessageType_remote_suspend_request:
	            intVal_pVal = 14UL;
	            break;
	        case MessageType_remote_suspend_response:
	            intVal_pVal = 15UL;
	            break;
	        case MessageType_remote_resume_request:
	            intVal_pVal = 16UL;
	            break;
	        case MessageType_remote_resume_response:
	            intVal_pVal = 17UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_ACN_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MESSAGETYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = MessageType_proxy_put_request;
	            break;
	        case 1:
	            (*(pVal)) = MessageType_proxy_message_to_user;
	            break;
	        case 2:
	            (*(pVal)) = MessageType_proxy_filestore_request;
	            break;
	        case 3:
	            (*(pVal)) = MessageType_proxy_fault_handler_override;
	            break;
	        case 4:
	            (*(pVal)) = MessageType_proxy_transmission_mode;
	            break;
	        case 5:
	            (*(pVal)) = MessageType_proxy_flow_label;
	            break;
	        case 6:
	            (*(pVal)) = MessageType_proxy_segmentation_control;
	            break;
	        case 7:
	            (*(pVal)) = MessageType_proxy_put_response;
	            break;
	        case 8:
	            (*(pVal)) = MessageType_proxy_filestore_response;
	            break;
	        case 9:
	            (*(pVal)) = MessageType_proxy_put_cancel;
	            break;
	        case 10:
	            (*(pVal)) = MessageType_directory_listing_request;
	            break;
	        case 11:
	            (*(pVal)) = MessageType_directory_listing_response;
	            break;
	        case 12:
	            (*(pVal)) = MessageType_remote_status_report_request;
	            break;
	        case 13:
	            (*(pVal)) = MessageType_remote_status_report_response;
	            break;
	        case 14:
	            (*(pVal)) = MessageType_remote_suspend_request;
	            break;
	        case 15:
	            (*(pVal)) = MessageType_remote_suspend_response;
	            break;
	        case 16:
	            (*(pVal)) = MessageType_remote_resume_request;
	            break;
	        case 17:
	            (*(pVal)) = MessageType_remote_resume_response;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpProtocolVersion_Equal(const cfdpProtocolVersion* pVal1, const cfdpProtocolVersion* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpProtocolVersion_IsConstraintValid(const cfdpProtocolVersion* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_PROTOCOLVERSION;

	return ret;
}

#ifdef __cplusplus
const cfdpProtocolVersion cfdpProtocolVersion_constant = 0UL;
#endif

void cfdpProtocolVersion_Initialize(cfdpProtocolVersion* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpProtocolVersion)cfdpProtocolVersion_constant;
}

flag cfdpProtocolVersion_Encode(const cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProtocolVersion_Decode(cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PROTOCOLVERSION;

	return ret  && cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode);
}

flag cfdpProtocolVersion_ACN_Encode(const cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProtocolVersion_ACN_Decode(cfdpProtocolVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PROTOCOLVERSION;

    return ret && cfdpProtocolVersion_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUType_Equal(const cfdpPDUType* pVal1, const cfdpPDUType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUType_IsConstraintValid(const cfdpPDUType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == PDUType_file_directive)) || (((*(pVal)) == PDUType_file_data)));
    *pErrCode = ret ? 0 :  ERR_PDUTYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUType cfdpPDUType_constant = PDUType_file_directive;
#endif

void cfdpPDUType_Initialize(cfdpPDUType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUType)cfdpPDUType_constant;
}

flag cfdpPDUType_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case PDUType_file_directive:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case PDUType_file_data:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PDUTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUTYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = PDUType_file_directive;
	                break;
	            case 1:
	                (*(pVal)) = PDUType_file_data;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PDUTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PDUType_file_directive;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUType_ACN_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case PDUType_file_directive:
	            intVal_pVal = 0UL;
	            break;
	        case PDUType_file_data:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PDUTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_ACN_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUTYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = PDUType_file_directive;
	            break;
	        case 1:
	            (*(pVal)) = PDUType_file_data;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PDUTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirection_Equal(const cfdpDirection* pVal1, const cfdpDirection* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirection_IsConstraintValid(const cfdpDirection* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == Direction_toward_receiver)) || (((*(pVal)) == Direction_toward_sender)));
    *pErrCode = ret ? 0 :  ERR_DIRECTION;

	return ret;
}

#ifdef __cplusplus
const cfdpDirection cfdpDirection_constant = Direction_toward_receiver;
#endif

void cfdpDirection_Initialize(cfdpDirection* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirection)cfdpDirection_constant;
}

flag cfdpDirection_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case Direction_toward_receiver:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case Direction_toward_sender:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTION;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = Direction_toward_receiver;
	                break;
	            case 1:
	                (*(pVal)) = Direction_toward_sender;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = Direction_toward_receiver;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirection_ACN_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case Direction_toward_receiver:
	            intVal_pVal = 0UL;
	            break;
	        case Direction_toward_sender:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_ACN_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTION;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = Direction_toward_receiver;
	            break;
	        case 1:
	            (*(pVal)) = Direction_toward_sender;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransmissionMode_Equal(const cfdpTransmissionMode* pVal1, const cfdpTransmissionMode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransmissionMode_IsConstraintValid(const cfdpTransmissionMode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == TransmissionMode_acknowledged)) || (((*(pVal)) == TransmissionMode_unacknowledged)));
    *pErrCode = ret ? 0 :  ERR_TRANSMISSIONMODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTransmissionMode cfdpTransmissionMode_constant = TransmissionMode_acknowledged;
#endif

void cfdpTransmissionMode_Initialize(cfdpTransmissionMode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransmissionMode)cfdpTransmissionMode_constant;
}

flag cfdpTransmissionMode_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransmissionMode_acknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case TransmissionMode_unacknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSMISSIONMODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSMISSIONMODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransmissionMode_acknowledged;
	                break;
	            case 1:
	                (*(pVal)) = TransmissionMode_unacknowledged;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSMISSIONMODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransmissionMode_acknowledged;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransmissionMode_ACN_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransmissionMode_acknowledged:
	            intVal_pVal = 0UL;
	            break;
	        case TransmissionMode_unacknowledged:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_ACN_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSMISSIONMODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransmissionMode_acknowledged;
	            break;
	        case 1:
	            (*(pVal)) = TransmissionMode_unacknowledged;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpCRCFlag_Equal(const cfdpCRCFlag* pVal1, const cfdpCRCFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpCRCFlag_IsConstraintValid(const cfdpCRCFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == CRCFlag_crc_not_present)) || (((*(pVal)) == CRCFlag_crc_present)));
    *pErrCode = ret ? 0 :  ERR_CRCFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpCRCFlag cfdpCRCFlag_constant = CRCFlag_crc_not_present;
#endif

void cfdpCRCFlag_Initialize(cfdpCRCFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpCRCFlag)cfdpCRCFlag_constant;
}

flag cfdpCRCFlag_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case CRCFlag_crc_not_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case CRCFlag_crc_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CRCFLAG; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CRCFLAG;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = CRCFlag_crc_not_present;
	                break;
	            case 1:
	                (*(pVal)) = CRCFlag_crc_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CRCFLAG;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = CRCFlag_crc_not_present;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpCRCFlag_ACN_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case CRCFlag_crc_not_present:
	            intVal_pVal = 0UL;
	            break;
	        case CRCFlag_crc_present:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_ACN_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CRCFLAG;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = CRCFlag_crc_not_present;
	            break;
	        case 1:
	            (*(pVal)) = CRCFlag_crc_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLargeFileFlag_Equal(const cfdpLargeFileFlag* pVal1, const cfdpLargeFileFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLargeFileFlag_IsConstraintValid(const cfdpLargeFileFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1UL);
    *pErrCode = ret ? 0 :  ERR_LARGEFILEFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpLargeFileFlag cfdpLargeFileFlag_constant = 0UL;
#endif

void cfdpLargeFileFlag_Initialize(cfdpLargeFileFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLargeFileFlag)cfdpLargeFileFlag_constant;
}

flag cfdpLargeFileFlag_Encode(const cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLargeFileFlag_Decode(cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LARGEFILEFLAG;

	return ret  && cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLargeFileFlag_ACN_Encode(const cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLargeFileFlag_ACN_Decode(cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LARGEFILEFLAG;

    return ret && cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUDataFieldLength_Equal(const cfdpPDUDataFieldLength* pVal1, const cfdpPDUDataFieldLength* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUDataFieldLength_IsConstraintValid(const cfdpPDUDataFieldLength* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_PDUDATAFIELDLENGTH;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUDataFieldLength cfdpPDUDataFieldLength_constant = 0UL;
#endif

void cfdpPDUDataFieldLength_Initialize(cfdpPDUDataFieldLength* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUDataFieldLength)cfdpPDUDataFieldLength_constant;
}

flag cfdpPDUDataFieldLength_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUDATAFIELDLENGTH;

	return ret  && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUDataFieldLength_ACN_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_ACN_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUDATAFIELDLENGTH;

    return ret && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}


flag cfdpSegmentationControl_Equal(const cfdpSegmentationControl* pVal1, const cfdpSegmentationControl* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpSegmentationControl_IsConstraintValid(const cfdpSegmentationControl* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == SegmentationControl_record_boundries_not_preserved)) || (((*(pVal)) == SegmentationControl_record_boundries_preserved)));
    *pErrCode = ret ? 0 :  ERR_SEGMENTATIONCONTROL;

	return ret;
}

#ifdef __cplusplus
const cfdpSegmentationControl cfdpSegmentationControl_constant = SegmentationControl_record_boundries_not_preserved;
#endif

void cfdpSegmentationControl_Initialize(cfdpSegmentationControl* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpSegmentationControl)cfdpSegmentationControl_constant;
}

flag cfdpSegmentationControl_Encode(const cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case SegmentationControl_record_boundries_not_preserved:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case SegmentationControl_record_boundries_preserved:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SEGMENTATIONCONTROL; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentationControl_Decode(cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SEGMENTATIONCONTROL;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = SegmentationControl_record_boundries_not_preserved;
	                break;
	            case 1:
	                (*(pVal)) = SegmentationControl_record_boundries_preserved;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SEGMENTATIONCONTROL;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = SegmentationControl_record_boundries_not_preserved;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode);
}

flag cfdpSegmentationControl_ACN_Encode(const cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case SegmentationControl_record_boundries_not_preserved:
	            intVal_pVal = 0UL;
	            break;
	        case SegmentationControl_record_boundries_preserved:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SEGMENTATIONCONTROL;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentationControl_ACN_Decode(cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SEGMENTATIONCONTROL;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = SegmentationControl_record_boundries_not_preserved;
	            break;
	        case 1:
	            (*(pVal)) = SegmentationControl_record_boundries_preserved;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SEGMENTATIONCONTROL;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfEntityIds_Equal(const cfdpLengthOfEntityIds* pVal1, const cfdpLengthOfEntityIds* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfEntityIds_IsConstraintValid(const cfdpLengthOfEntityIds* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFENTITYIDS;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfEntityIds cfdpLengthOfEntityIds_constant = 0UL;
#endif

void cfdpLengthOfEntityIds_Initialize(cfdpLengthOfEntityIds* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfEntityIds)cfdpLengthOfEntityIds_constant;
}

flag cfdpLengthOfEntityIds_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFENTITYIDS;

	return ret  && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfEntityIds_ACN_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_ACN_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFENTITYIDS;

    return ret && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}


flag cfdpSegmentMetadataFlag_Equal(const cfdpSegmentMetadataFlag* pVal1, const cfdpSegmentMetadataFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpSegmentMetadataFlag_IsConstraintValid(const cfdpSegmentMetadataFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == SegmentMetadataFlag_flag_present)) || (((*(pVal)) == SegmentMetadataFlag_flag_not_present)));
    *pErrCode = ret ? 0 :  ERR_SEGMENTMETADATAFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpSegmentMetadataFlag cfdpSegmentMetadataFlag_constant = SegmentMetadataFlag_flag_present;
#endif

void cfdpSegmentMetadataFlag_Initialize(cfdpSegmentMetadataFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpSegmentMetadataFlag)cfdpSegmentMetadataFlag_constant;
}

flag cfdpSegmentMetadataFlag_Encode(const cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case SegmentMetadataFlag_flag_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case SegmentMetadataFlag_flag_not_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SEGMENTMETADATAFLAG; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentMetadataFlag_Decode(cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SEGMENTMETADATAFLAG;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = SegmentMetadataFlag_flag_present;
	                break;
	            case 1:
	                (*(pVal)) = SegmentMetadataFlag_flag_not_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SEGMENTMETADATAFLAG;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = SegmentMetadataFlag_flag_present;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpSegmentMetadataFlag_ACN_Encode(const cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case SegmentMetadataFlag_flag_present:
	            intVal_pVal = 0UL;
	            break;
	        case SegmentMetadataFlag_flag_not_present:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SEGMENTMETADATAFLAG;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentMetadataFlag_ACN_Decode(cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SEGMENTMETADATAFLAG;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = SegmentMetadataFlag_flag_present;
	            break;
	        case 1:
	            (*(pVal)) = SegmentMetadataFlag_flag_not_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SEGMENTMETADATAFLAG;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfTransactionSequenceNumber_Equal(const cfdpLengthOfTransactionSequenceNumber* pVal1, const cfdpLengthOfTransactionSequenceNumber* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(const cfdpLengthOfTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfTransactionSequenceNumber cfdpLengthOfTransactionSequenceNumber_constant = 0UL;
#endif

void cfdpLengthOfTransactionSequenceNumber_Initialize(cfdpLengthOfTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfTransactionSequenceNumber)cfdpLengthOfTransactionSequenceNumber_constant;
}

flag cfdpLengthOfTransactionSequenceNumber_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret  && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

    return ret && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpEntityId_Equal(const cfdpEntityId* pVal1, const cfdpEntityId* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpEntityId_IsConstraintValid(const cfdpEntityId* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_ENTITYID;

	return ret;
}

#ifdef __cplusplus
const cfdpEntityId cfdpEntityId_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpEntityId_Initialize(cfdpEntityId* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpEntityId)cfdpEntityId_constant;
}

flag cfdpEntityId_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}

flag cfdpEntityId_ACN_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_ACN_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionSequenceNumber_Equal(const cfdpTransactionSequenceNumber* pVal1, const cfdpTransactionSequenceNumber* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpTransactionSequenceNumber_IsConstraintValid(const cfdpTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionSequenceNumber cfdpTransactionSequenceNumber_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpTransactionSequenceNumber_Initialize(cfdpTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionSequenceNumber)cfdpTransactionSequenceNumber_constant;
}

flag cfdpTransactionSequenceNumber_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionSequenceNumber_ACN_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_ACN_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUHeader_Equal(const cfdpPDUHeader* pVal1, const cfdpPDUHeader* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->version == pVal2->version);

    if (ret) {
        ret = (pVal1->pdu_type == pVal2->pdu_type);

        if (ret) {
            ret = (pVal1->direction == pVal2->direction);

            if (ret) {
                ret = (pVal1->transmission_mode == pVal2->transmission_mode);

                if (ret) {
                    ret = (pVal1->crc_flag == pVal2->crc_flag);

                    if (ret) {
                        ret = (pVal1->large_file_flag == pVal2->large_file_flag);

                        if (ret) {
                            ret = (pVal1->pdu_data_field_length == pVal2->pdu_data_field_length);

                            if (ret) {
                                ret = (pVal1->segmentation_control == pVal2->segmentation_control);

                                if (ret) {
                                    ret = (pVal1->segment_metadata_flag == pVal2->segment_metadata_flag);

                                    if (ret) {
                                        ret = cfdpEntityId_Equal((&(pVal1->source_entity_id)), (&(pVal2->source_entity_id)));

                                        if (ret) {
                                            ret = cfdpTransactionSequenceNumber_Equal((&(pVal1->transaction_sequence_number)), (&(pVal2->transaction_sequence_number)));

                                            if (ret) {
                                                ret = cfdpEntityId_Equal((&(pVal1->destination_entity_id)), (&(pVal2->destination_entity_id)));

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag cfdpPDUHeader_IsConstraintValid(const cfdpPDUHeader* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpProtocolVersion_IsConstraintValid((&(pVal->version)), pErrCode);
    if (ret) {
        ret = cfdpPDUType_IsConstraintValid((&(pVal->pdu_type)), pErrCode);
        if (ret) {
            ret = cfdpDirection_IsConstraintValid((&(pVal->direction)), pErrCode);
            if (ret) {
                ret = cfdpTransmissionMode_IsConstraintValid((&(pVal->transmission_mode)), pErrCode);
                if (ret) {
                    ret = cfdpCRCFlag_IsConstraintValid((&(pVal->crc_flag)), pErrCode);
                    if (ret) {
                        ret = cfdpLargeFileFlag_IsConstraintValid((&(pVal->large_file_flag)), pErrCode);
                        if (ret) {
                            ret = cfdpPDUDataFieldLength_IsConstraintValid((&(pVal->pdu_data_field_length)), pErrCode);
                            if (ret) {
                                ret = cfdpSegmentationControl_IsConstraintValid((&(pVal->segmentation_control)), pErrCode);
                                if (ret) {
                                    ret = cfdpSegmentMetadataFlag_IsConstraintValid((&(pVal->segment_metadata_flag)), pErrCode);
                                    if (ret) {
                                        ret = cfdpEntityId_IsConstraintValid((&(pVal->source_entity_id)), pErrCode);
                                        if (ret) {
                                            ret = cfdpTransactionSequenceNumber_IsConstraintValid((&(pVal->transaction_sequence_number)), pErrCode);
                                            if (ret) {
                                                ret = cfdpEntityId_IsConstraintValid((&(pVal->destination_entity_id)), pErrCode);
                                            }   /*COVERAGE_IGNORE*/
                                        }   /*COVERAGE_IGNORE*/
                                    }   /*COVERAGE_IGNORE*/
                                }   /*COVERAGE_IGNORE*/
                            }   /*COVERAGE_IGNORE*/
                        }   /*COVERAGE_IGNORE*/
                    }   /*COVERAGE_IGNORE*/
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpPDUHeader cfdpPDUHeader_constant = {.version = 0UL, .pdu_type = PDUType_file_directive, .direction = Direction_toward_receiver, .transmission_mode = TransmissionMode_acknowledged, .crc_flag = CRCFlag_crc_not_present, .large_file_flag = 0UL, .pdu_data_field_length = 0UL, .segmentation_control = SegmentationControl_record_boundries_not_preserved, .segment_metadata_flag = SegmentMetadataFlag_flag_present, .source_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .transaction_sequence_number = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .destination_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}};
#endif

void cfdpPDUHeader_Initialize(cfdpPDUHeader* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUHeader)cfdpPDUHeader_constant;
}

flag cfdpPDUHeader_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpProtocolVersion_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pdu_type */
	        ret = cfdpPDUType_Encode((&(pVal->pdu_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode direction */
	            ret = cfdpDirection_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transmission_mode */
	                ret = cfdpTransmissionMode_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode crc_flag */
	                    ret = cfdpCRCFlag_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode large_file_flag */
	                        ret = cfdpLargeFileFlag_Encode((&(pVal->large_file_flag)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode pdu_data_field_length */
	                            ret = cfdpPDUDataFieldLength_Encode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode segmentation_control */
	                                ret = cfdpSegmentationControl_Encode((&(pVal->segmentation_control)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode segment_metadata_flag */
	                                    ret = cfdpSegmentMetadataFlag_Encode((&(pVal->segment_metadata_flag)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode source_entity_id */
	                                        ret = cfdpEntityId_Encode((&(pVal->source_entity_id)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode transaction_sequence_number */
	                                            ret = cfdpTransactionSequenceNumber_Encode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode destination_entity_id */
	                                                ret = cfdpEntityId_Encode((&(pVal->destination_entity_id)), pBitStrm, pErrCode, FALSE);
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode version */
	ret = cfdpProtocolVersion_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pdu_type */
	    ret = cfdpPDUType_Decode((&(pVal->pdu_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode direction */
	        ret = cfdpDirection_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transmission_mode */
	            ret = cfdpTransmissionMode_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode crc_flag */
	                ret = cfdpCRCFlag_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode large_file_flag */
	                    ret = cfdpLargeFileFlag_Decode((&(pVal->large_file_flag)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode pdu_data_field_length */
	                        ret = cfdpPDUDataFieldLength_Decode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode segmentation_control */
	                            ret = cfdpSegmentationControl_Decode((&(pVal->segmentation_control)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode segment_metadata_flag */
	                                ret = cfdpSegmentMetadataFlag_Decode((&(pVal->segment_metadata_flag)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode source_entity_id */
	                                    ret = cfdpEntityId_Decode((&(pVal->source_entity_id)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode transaction_sequence_number */
	                                        ret = cfdpTransactionSequenceNumber_Decode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode destination_entity_id */
	                                            ret = cfdpEntityId_Decode((&(pVal->destination_entity_id)), pBitStrm, pErrCode);
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUHeader_ACN_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint PDUHeader_length_of_entity_ids;
	flag PDUHeader_length_of_entity_ids_is_initialized=FALSE;
	asn1SccUint PDUHeader_length_of_transaction_sequence_number;
	flag PDUHeader_length_of_transaction_sequence_number_is_initialized=FALSE;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpProtocolVersion_ACN_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pdu_type */
	        ret = cfdpPDUType_ACN_Encode((&(pVal->pdu_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode direction */
	            ret = cfdpDirection_ACN_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transmission_mode */
	                ret = cfdpTransmissionMode_ACN_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode crc_flag */
	                    ret = cfdpCRCFlag_ACN_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode large_file_flag */
	                        ret = cfdpLargeFileFlag_ACN_Encode((&(pVal->large_file_flag)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode pdu_data_field_length */
	                            ret = cfdpPDUDataFieldLength_ACN_Encode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode segmentation_control */
	                                ret = cfdpSegmentationControl_ACN_Encode((&(pVal->segmentation_control)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    {
	                                        asn1SccUint PDUHeader_length_of_entity_ids00;
	                                        flag PDUHeader_length_of_entity_ids00_is_initialized=FALSE;
	                                        asn1SccUint PDUHeader_length_of_entity_ids01;
	                                        flag PDUHeader_length_of_entity_ids01_is_initialized=FALSE;

	                                        PDUHeader_length_of_entity_ids00_is_initialized = TRUE;
	                                        PDUHeader_length_of_entity_ids00 = pVal->destination_entity_id.nCount;
	                                        PDUHeader_length_of_entity_ids01_is_initialized = TRUE;
	                                        PDUHeader_length_of_entity_ids01 = pVal->source_entity_id.nCount;

	                                        if (ret) {

	                                            *pErrCode = ERR_ACN_ENCODE_UPDATE_PDUHEADER_LENGTH_OF_ENTITY_IDS;
	                                            if (PDUHeader_length_of_entity_ids00_is_initialized) { /*COVERAGE_IGNORE*/
	                                                PDUHeader_length_of_entity_ids = PDUHeader_length_of_entity_ids00; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else if (PDUHeader_length_of_entity_ids01_is_initialized) { /*COVERAGE_IGNORE*/
	                                                PDUHeader_length_of_entity_ids = PDUHeader_length_of_entity_ids01; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else {
	                                                ret = FALSE; /*COVERAGE_IGNORE*/
	                                            }
	                                            if (ret) {
	                                                ret = (((PDUHeader_length_of_entity_ids00_is_initialized && PDUHeader_length_of_entity_ids == PDUHeader_length_of_entity_ids00) || !PDUHeader_length_of_entity_ids00_is_initialized) && ((PDUHeader_length_of_entity_ids01_is_initialized && PDUHeader_length_of_entity_ids == PDUHeader_length_of_entity_ids01) || !PDUHeader_length_of_entity_ids01_is_initialized));
	                                                PDUHeader_length_of_entity_ids_is_initialized = TRUE;
	                                            }
	                                        }
	                                    }
	                                    if (ret) {
	                                        /*Encode PDUHeader_length_of_entity_ids */
	                                        if (PDUHeader_length_of_entity_ids_is_initialized) {
	                                            ret = TRUE;
	                                            Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, PDUHeader_length_of_entity_ids, 3);
	                                        } else {
	                                            *pErrCode = ERR_ACN_ENCODE_PDUHEADER_LENGTH_OF_ENTITY_IDS_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                        }
	                                    }   /*COVERAGE_IGNORE*/
	                                    if (ret) {
	                                        /*Encode segment_metadata_flag */
	                                        ret = cfdpSegmentMetadataFlag_ACN_Encode((&(pVal->segment_metadata_flag)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            PDUHeader_length_of_transaction_sequence_number_is_initialized = TRUE;
	                                            PDUHeader_length_of_transaction_sequence_number = pVal->transaction_sequence_number.nCount;
	                                            if (ret) {
	                                                /*Encode PDUHeader_length_of_transaction_sequence_number */
	                                                if (PDUHeader_length_of_transaction_sequence_number_is_initialized) {
	                                                    ret = TRUE;
	                                                    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, PDUHeader_length_of_transaction_sequence_number, 3);
	                                                } else {
	                                                    *pErrCode = ERR_ACN_ENCODE_PDUHEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                                }
	                                            }   /*COVERAGE_IGNORE*/
	                                            if (ret) {
	                                                /*Encode source_entity_id */
	                                                ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->source_entity_id.arr, pVal->source_entity_id.nCount);
	                                                if (ret) {
	                                                    /*Encode transaction_sequence_number */
	                                                    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->transaction_sequence_number.arr, pVal->transaction_sequence_number.nCount);
	                                                    if (ret) {
	                                                        /*Encode destination_entity_id */
	                                                        ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->destination_entity_id.arr, pVal->destination_entity_id.nCount);
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_ACN_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint PDUHeader_length_of_entity_ids;
	asn1SccUint PDUHeader_length_of_transaction_sequence_number;

	/*Decode version */
	ret = cfdpProtocolVersion_ACN_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pdu_type */
	    ret = cfdpPDUType_ACN_Decode((&(pVal->pdu_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode direction */
	        ret = cfdpDirection_ACN_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transmission_mode */
	            ret = cfdpTransmissionMode_ACN_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode crc_flag */
	                ret = cfdpCRCFlag_ACN_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode large_file_flag */
	                    ret = cfdpLargeFileFlag_ACN_Decode((&(pVal->large_file_flag)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode pdu_data_field_length */
	                        ret = cfdpPDUDataFieldLength_ACN_Decode((&(pVal->pdu_data_field_length)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode segmentation_control */
	                            ret = cfdpSegmentationControl_ACN_Decode((&(pVal->segmentation_control)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode PDUHeader_length_of_entity_ids */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(PDUHeader_length_of_entity_ids)), 3);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_LENGTH_OF_ENTITY_IDS;
	                                if (ret) {
	                                    /*Decode segment_metadata_flag */
	                                    ret = cfdpSegmentMetadataFlag_ACN_Decode((&(pVal->segment_metadata_flag)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode PDUHeader_length_of_transaction_sequence_number */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(PDUHeader_length_of_transaction_sequence_number)), 3);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER;
	                                        if (ret) {
	                                            /*Decode source_entity_id */
	                                            ret = ((1<=PDUHeader_length_of_entity_ids) && (PDUHeader_length_of_entity_ids<=7));
	                                            if (ret) {
	                                                pVal->source_entity_id.nCount = (int)PDUHeader_length_of_entity_ids;
	                                                ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->source_entity_id.arr, pVal->source_entity_id.nCount);
	                                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_SOURCE_ENTITY_ID;
	                                            }
	                                            if (ret) {
	                                                /*Decode transaction_sequence_number */
	                                                ret = ((1<=PDUHeader_length_of_transaction_sequence_number) && (PDUHeader_length_of_transaction_sequence_number<=7));
	                                                if (ret) {
	                                                    pVal->transaction_sequence_number.nCount = (int)PDUHeader_length_of_transaction_sequence_number;
	                                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->transaction_sequence_number.arr, pVal->transaction_sequence_number.nCount);
	                                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_TRANSACTION_SEQUENCE_NUMBER;
	                                                }
	                                                if (ret) {
	                                                    /*Decode destination_entity_id */
	                                                    ret = ((1<=PDUHeader_length_of_entity_ids) && (PDUHeader_length_of_entity_ids<=7));
	                                                    if (ret) {
	                                                        pVal->destination_entity_id.nCount = (int)PDUHeader_length_of_entity_ids;
	                                                        ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->destination_entity_id.arr, pVal->destination_entity_id.nCount);
	                                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUHEADER_DESTINATION_ENTITY_ID;
	                                                    }
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}


