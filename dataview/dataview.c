/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"
#include "mapping_functions.h"

#include "dataview.h"



flag cfdpDirectiveCode_Equal(const cfdpDirectiveCode* pVal1, const cfdpDirectiveCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveCode_IsConstraintValid(const cfdpDirectiveCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_DIRECTIVECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveCode cfdpDirectiveCode_constant = 0UL;
#endif

void cfdpDirectiveCode_Initialize(cfdpDirectiveCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveCode)cfdpDirectiveCode_constant;
}

flag cfdpDirectiveCode_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVECODE;

	return ret  && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveCode_ACN_Encode(const cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveCode_ACN_Decode(cfdpDirectiveCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVECODE;

    return ret && cfdpDirectiveCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirectiveSubtypeCode_Equal(const cfdpDirectiveSubtypeCode* pVal1, const cfdpDirectiveSubtypeCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirectiveSubtypeCode_IsConstraintValid(const cfdpDirectiveSubtypeCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DirectiveSubtypeCode_ack_others)) || (((*(pVal)) == DirectiveSubtypeCode_ack_finished)));
    *pErrCode = ret ? 0 :  ERR_DIRECTIVESUBTYPECODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDirectiveSubtypeCode cfdpDirectiveSubtypeCode_constant = DirectiveSubtypeCode_ack_others;
#endif

void cfdpDirectiveSubtypeCode_Initialize(cfdpDirectiveSubtypeCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirectiveSubtypeCode)cfdpDirectiveSubtypeCode_constant;
}

flag cfdpDirectiveSubtypeCode_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DirectiveSubtypeCode_ack_others:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DirectiveSubtypeCode_ack_finished:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTIVESUBTYPECODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DirectiveSubtypeCode_ack_others;
	                break;
	            case 1:
	                (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTIVESUBTYPECODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DirectiveSubtypeCode_ack_others;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirectiveSubtypeCode_ACN_Encode(const cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DirectiveSubtypeCode_ack_others:
	            intVal_pVal = 0UL;
	            break;
	        case DirectiveSubtypeCode_ack_finished:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirectiveSubtypeCode_ACN_Decode(cfdpDirectiveSubtypeCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DirectiveSubtypeCode_ack_others;
	            break;
	        case 1:
	            (*(pVal)) = DirectiveSubtypeCode_ack_finished;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTIVESUBTYPECODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirectiveSubtypeCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpConditionCode_Equal(const cfdpConditionCode* pVal1, const cfdpConditionCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpConditionCode_IsConstraintValid(const cfdpConditionCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((*(pVal)) == ConditionCode_no_error)) || (((*(pVal)) == ConditionCode_positive_ack_limit_reached)))) || (((*(pVal)) == ConditionCode_keep_alive_limit_reached)))) || (((*(pVal)) == ConditionCode_invalid_transmission_mode)))) || (((*(pVal)) == ConditionCode_filestore_rejection)))) || (((*(pVal)) == ConditionCode_file_checksum_failure)))) || (((*(pVal)) == ConditionCode_file_size_error)))) || (((*(pVal)) == ConditionCode_nak_limit_reached)))) || (((*(pVal)) == ConditionCode_inactivity_detected)))) || (((*(pVal)) == ConditionCode_invalid_file_structure)))) || (((*(pVal)) == ConditionCode_check_limit_reached)))) || (((*(pVal)) == ConditionCode_unsupported_checksum_type)))) || (((*(pVal)) == ConditionCode_suspend_request_received)))) || (((*(pVal)) == ConditionCode_cancel_request_received)));
    *pErrCode = ret ? 0 :  ERR_CONDITIONCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpConditionCode cfdpConditionCode_constant = ConditionCode_no_error;
#endif

void cfdpConditionCode_Initialize(cfdpConditionCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpConditionCode)cfdpConditionCode_constant;
}

flag cfdpConditionCode_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ConditionCode_no_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 13);
	        	break;
	        case ConditionCode_positive_ack_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 13);
	        	break;
	        case ConditionCode_keep_alive_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 13);
	        	break;
	        case ConditionCode_invalid_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 13);
	        	break;
	        case ConditionCode_filestore_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 13);
	        	break;
	        case ConditionCode_file_checksum_failure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 13);
	        	break;
	        case ConditionCode_file_size_error:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 13);
	        	break;
	        case ConditionCode_nak_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 13);
	        	break;
	        case ConditionCode_inactivity_detected:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 13);
	        	break;
	        case ConditionCode_invalid_file_structure:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 13);
	        	break;
	        case ConditionCode_check_limit_reached:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 13);
	        	break;
	        case ConditionCode_unsupported_checksum_type:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 13);
	        	break;
	        case ConditionCode_suspend_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 13);
	        	break;
	        case ConditionCode_cancel_request_received:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 13);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONDITIONCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 13);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONDITIONCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ConditionCode_no_error;
	                break;
	            case 1:
	                (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	                break;
	            case 2:
	                (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	                break;
	            case 3:
	                (*(pVal)) = ConditionCode_invalid_transmission_mode;
	                break;
	            case 4:
	                (*(pVal)) = ConditionCode_filestore_rejection;
	                break;
	            case 5:
	                (*(pVal)) = ConditionCode_file_checksum_failure;
	                break;
	            case 6:
	                (*(pVal)) = ConditionCode_file_size_error;
	                break;
	            case 7:
	                (*(pVal)) = ConditionCode_nak_limit_reached;
	                break;
	            case 8:
	                (*(pVal)) = ConditionCode_inactivity_detected;
	                break;
	            case 9:
	                (*(pVal)) = ConditionCode_invalid_file_structure;
	                break;
	            case 10:
	                (*(pVal)) = ConditionCode_check_limit_reached;
	                break;
	            case 11:
	                (*(pVal)) = ConditionCode_unsupported_checksum_type;
	                break;
	            case 12:
	                (*(pVal)) = ConditionCode_suspend_request_received;
	                break;
	            case 13:
	                (*(pVal)) = ConditionCode_cancel_request_received;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONDITIONCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ConditionCode_no_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpConditionCode_ACN_Encode(const cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpConditionCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ConditionCode_no_error:
	            intVal_pVal = 0UL;
	            break;
	        case ConditionCode_positive_ack_limit_reached:
	            intVal_pVal = 1UL;
	            break;
	        case ConditionCode_keep_alive_limit_reached:
	            intVal_pVal = 2UL;
	            break;
	        case ConditionCode_invalid_transmission_mode:
	            intVal_pVal = 3UL;
	            break;
	        case ConditionCode_filestore_rejection:
	            intVal_pVal = 4UL;
	            break;
	        case ConditionCode_file_checksum_failure:
	            intVal_pVal = 5UL;
	            break;
	        case ConditionCode_file_size_error:
	            intVal_pVal = 6UL;
	            break;
	        case ConditionCode_nak_limit_reached:
	            intVal_pVal = 7UL;
	            break;
	        case ConditionCode_inactivity_detected:
	            intVal_pVal = 8UL;
	            break;
	        case ConditionCode_invalid_file_structure:
	            intVal_pVal = 9UL;
	            break;
	        case ConditionCode_check_limit_reached:
	            intVal_pVal = 10UL;
	            break;
	        case ConditionCode_unsupported_checksum_type:
	            intVal_pVal = 11UL;
	            break;
	        case ConditionCode_suspend_request_received:
	            intVal_pVal = 12UL;
	            break;
	        case ConditionCode_cancel_request_received:
	            intVal_pVal = 13UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpConditionCode_ACN_Decode(cfdpConditionCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONDITIONCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ConditionCode_no_error;
	            break;
	        case 1:
	            (*(pVal)) = ConditionCode_positive_ack_limit_reached;
	            break;
	        case 2:
	            (*(pVal)) = ConditionCode_keep_alive_limit_reached;
	            break;
	        case 3:
	            (*(pVal)) = ConditionCode_invalid_transmission_mode;
	            break;
	        case 4:
	            (*(pVal)) = ConditionCode_filestore_rejection;
	            break;
	        case 5:
	            (*(pVal)) = ConditionCode_file_checksum_failure;
	            break;
	        case 6:
	            (*(pVal)) = ConditionCode_file_size_error;
	            break;
	        case 7:
	            (*(pVal)) = ConditionCode_nak_limit_reached;
	            break;
	        case 8:
	            (*(pVal)) = ConditionCode_inactivity_detected;
	            break;
	        case 9:
	            (*(pVal)) = ConditionCode_invalid_file_structure;
	            break;
	        case 10:
	            (*(pVal)) = ConditionCode_check_limit_reached;
	            break;
	        case 11:
	            (*(pVal)) = ConditionCode_unsupported_checksum_type;
	            break;
	        case 12:
	            (*(pVal)) = ConditionCode_suspend_request_received;
	            break;
	        case 13:
	            (*(pVal)) = ConditionCode_cancel_request_received;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONDITIONCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpConditionCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileChecksum_Equal(const cfdpFileChecksum* pVal1, const cfdpFileChecksum* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileChecksum_IsConstraintValid(const cfdpFileChecksum* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_FILECHECKSUM;

	return ret;
}

#ifdef __cplusplus
const cfdpFileChecksum cfdpFileChecksum_constant = 0UL;
#endif

void cfdpFileChecksum_Initialize(cfdpFileChecksum* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileChecksum)cfdpFileChecksum_constant;
}

flag cfdpFileChecksum_Encode(const cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileChecksum_Decode(cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILECHECKSUM;

	return ret  && cfdpFileChecksum_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileChecksum_ACN_Encode(const cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileChecksum_ACN_Decode(cfdpFileChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILECHECKSUM;

    return ret && cfdpFileChecksum_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileSize_Equal(const cfdpFileSize* pVal1, const cfdpFileSize* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileSize_IsConstraintValid(const cfdpFileSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_FILESIZE;

	return ret;
}

#ifdef __cplusplus
const cfdpFileSize cfdpFileSize_constant = 0UL;
#endif

void cfdpFileSize_Initialize(cfdpFileSize* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileSize)cfdpFileSize_constant;
}

flag cfdpFileSize_Encode(const cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileSize_Decode(cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILESIZE;

	return ret  && cfdpFileSize_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileSize_ACN_Encode(const cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileSize_ACN_Decode(cfdpFileSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILESIZE;

    return ret && cfdpFileSize_IsConstraintValid(pVal, pErrCode);
}


flag cfdpEofPDU_Equal(const cfdpEofPDU* pVal1, const cfdpEofPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->condition_code == pVal2->condition_code);

    if (ret) {
        ret = (pVal1->file_checksum == pVal2->file_checksum);

        if (ret) {
            ret = (pVal1->file_size == pVal2->file_size);

        }

    }

	return ret;

}

flag cfdpEofPDU_IsConstraintValid(const cfdpEofPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
    if (ret) {
        ret = cfdpFileChecksum_IsConstraintValid((&(pVal->file_checksum)), pErrCode);
        if (ret) {
            ret = cfdpFileSize_IsConstraintValid((&(pVal->file_size)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpEofPDU cfdpEofPDU_constant = {.condition_code = ConditionCode_no_error, .file_checksum = 0UL, .file_size = 0UL};
#endif

void cfdpEofPDU_Initialize(cfdpEofPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpEofPDU)cfdpEofPDU_constant;
}

flag cfdpEofPDU_Encode(const cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpEofPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode file_checksum */
	        ret = cfdpFileChecksum_Encode((&(pVal->file_checksum)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_size */
	            ret = cfdpFileSize_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEofPDU_Decode(cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode file_checksum */
	    ret = cfdpFileChecksum_Decode((&(pVal->file_checksum)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_size */
	        ret = cfdpFileSize_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpEofPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpEofPDU_ACN_Encode(const cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal_condition_code;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpEofPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    switch(pVal->condition_code) {
	        case ConditionCode_no_error:
	            intVal_pVal_condition_code = 0UL;
	            break;
	        case ConditionCode_positive_ack_limit_reached:
	            intVal_pVal_condition_code = 1UL;
	            break;
	        case ConditionCode_keep_alive_limit_reached:
	            intVal_pVal_condition_code = 2UL;
	            break;
	        case ConditionCode_invalid_transmission_mode:
	            intVal_pVal_condition_code = 3UL;
	            break;
	        case ConditionCode_filestore_rejection:
	            intVal_pVal_condition_code = 4UL;
	            break;
	        case ConditionCode_file_checksum_failure:
	            intVal_pVal_condition_code = 5UL;
	            break;
	        case ConditionCode_file_size_error:
	            intVal_pVal_condition_code = 6UL;
	            break;
	        case ConditionCode_nak_limit_reached:
	            intVal_pVal_condition_code = 7UL;
	            break;
	        case ConditionCode_inactivity_detected:
	            intVal_pVal_condition_code = 8UL;
	            break;
	        case ConditionCode_invalid_file_structure:
	            intVal_pVal_condition_code = 9UL;
	            break;
	        case ConditionCode_check_limit_reached:
	            intVal_pVal_condition_code = 10UL;
	            break;
	        case ConditionCode_unsupported_checksum_type:
	            intVal_pVal_condition_code = 11UL;
	            break;
	        case ConditionCode_suspend_request_received:
	            intVal_pVal_condition_code = 12UL;
	            break;
	        case ConditionCode_cancel_request_received:
	            intVal_pVal_condition_code = 13UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_EOFPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_condition_code, 4);
	    }
	    if (ret) {
	        /*Encode EofPDU_spare */
	        {
	        	static byte tmp[] = {0x00};
	        	BitStream_AppendBits(pBitStrm, tmp, 4);
	        }
	        if (ret) {
	            /*Encode file_checksum */
	            Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_checksum);
	            if (ret) {
	                /*Encode file_size */
	                Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_size);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEofPDU_ACN_Decode(cfdpEofPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal_condition_code;

	/*Decode condition_code */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_condition_code)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_EOFPDU_CONDITION_CODE;
	if (ret) {
	    switch (intVal_pVal_condition_code) {
	        case 0:
	            pVal->condition_code = ConditionCode_no_error;
	            break;
	        case 1:
	            pVal->condition_code = ConditionCode_positive_ack_limit_reached;
	            break;
	        case 2:
	            pVal->condition_code = ConditionCode_keep_alive_limit_reached;
	            break;
	        case 3:
	            pVal->condition_code = ConditionCode_invalid_transmission_mode;
	            break;
	        case 4:
	            pVal->condition_code = ConditionCode_filestore_rejection;
	            break;
	        case 5:
	            pVal->condition_code = ConditionCode_file_checksum_failure;
	            break;
	        case 6:
	            pVal->condition_code = ConditionCode_file_size_error;
	            break;
	        case 7:
	            pVal->condition_code = ConditionCode_nak_limit_reached;
	            break;
	        case 8:
	            pVal->condition_code = ConditionCode_inactivity_detected;
	            break;
	        case 9:
	            pVal->condition_code = ConditionCode_invalid_file_structure;
	            break;
	        case 10:
	            pVal->condition_code = ConditionCode_check_limit_reached;
	            break;
	        case 11:
	            pVal->condition_code = ConditionCode_unsupported_checksum_type;
	            break;
	        case 12:
	            pVal->condition_code = ConditionCode_suspend_request_received;
	            break;
	        case 13:
	            pVal->condition_code = ConditionCode_cancel_request_received;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_EOFPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode EofPDU_spare */
	    {
	    	static byte tmp[] = {0x00};
	        flag bDecodingPatternMatches;
	    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 4, &bDecodingPatternMatches);
	        ret = ret && bDecodingPatternMatches;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_EOFPDU_SPARE;
	    }

	    if (ret) {
	        /*Decode file_checksum */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_checksum)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_EOFPDU_FILE_CHECKSUM;
	        if (ret) {
	            /*Decode file_size */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_size)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_EOFPDU_FILE_SIZE;
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpEofPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpAckTransactionStatus_Equal(const cfdpAckTransactionStatus* pVal1, const cfdpAckTransactionStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpAckTransactionStatus_IsConstraintValid(const cfdpAckTransactionStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == AckTransactionStatus_undefined)) || (((*(pVal)) == AckTransactionStatus_active)))) || (((*(pVal)) == AckTransactionStatus_terminated)))) || (((*(pVal)) == AckTransactionStatus_unrecognized)));
    *pErrCode = ret ? 0 :  ERR_ACKTRANSACTIONSTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpAckTransactionStatus cfdpAckTransactionStatus_constant = AckTransactionStatus_undefined;
#endif

void cfdpAckTransactionStatus_Initialize(cfdpAckTransactionStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpAckTransactionStatus)cfdpAckTransactionStatus_constant;
}

flag cfdpAckTransactionStatus_Encode(const cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case AckTransactionStatus_undefined:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case AckTransactionStatus_active:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case AckTransactionStatus_terminated:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case AckTransactionStatus_unrecognized:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_ACKTRANSACTIONSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckTransactionStatus_Decode(cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_ACKTRANSACTIONSTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = AckTransactionStatus_undefined;
	                break;
	            case 1:
	                (*(pVal)) = AckTransactionStatus_active;
	                break;
	            case 2:
	                (*(pVal)) = AckTransactionStatus_terminated;
	                break;
	            case 3:
	                (*(pVal)) = AckTransactionStatus_unrecognized;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_ACKTRANSACTIONSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = AckTransactionStatus_undefined;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpAckTransactionStatus_ACN_Encode(const cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case AckTransactionStatus_undefined:
	            intVal_pVal = 0UL;
	            break;
	        case AckTransactionStatus_active:
	            intVal_pVal = 1UL;
	            break;
	        case AckTransactionStatus_terminated:
	            intVal_pVal = 2UL;
	            break;
	        case AckTransactionStatus_unrecognized:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_ACKTRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckTransactionStatus_ACN_Decode(cfdpAckTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKTRANSACTIONSTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = AckTransactionStatus_undefined;
	            break;
	        case 1:
	            (*(pVal)) = AckTransactionStatus_active;
	            break;
	        case 2:
	            (*(pVal)) = AckTransactionStatus_terminated;
	            break;
	        case 3:
	            (*(pVal)) = AckTransactionStatus_unrecognized;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_ACKTRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpAckTransactionStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpAckPDU_Equal(const cfdpAckPDU* pVal1, const cfdpAckPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->directive_code_of_ack_pdu == pVal2->directive_code_of_ack_pdu);

    if (ret) {
        ret = (pVal1->directive_subtype_code == pVal2->directive_subtype_code);

        if (ret) {
            ret = (pVal1->condition_code == pVal2->condition_code);

            if (ret) {
                ret = (pVal1->transaction_status == pVal2->transaction_status);

            }

        }

    }

	return ret;

}

flag cfdpAckPDU_IsConstraintValid(const cfdpAckPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpDirectiveCode_IsConstraintValid((&(pVal->directive_code_of_ack_pdu)), pErrCode);
    if (ret) {
        ret = cfdpDirectiveSubtypeCode_IsConstraintValid((&(pVal->directive_subtype_code)), pErrCode);
        if (ret) {
            ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
            if (ret) {
                ret = cfdpAckTransactionStatus_IsConstraintValid((&(pVal->transaction_status)), pErrCode);
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpAckPDU cfdpAckPDU_constant = {.directive_code_of_ack_pdu = 0UL, .directive_subtype_code = DirectiveSubtypeCode_ack_others, .condition_code = ConditionCode_no_error, .transaction_status = AckTransactionStatus_undefined};
#endif

void cfdpAckPDU_Initialize(cfdpAckPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpAckPDU)cfdpAckPDU_constant;
}

flag cfdpAckPDU_Encode(const cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode directive_code_of_ack_pdu */
	    ret = cfdpDirectiveCode_Encode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode directive_subtype_code */
	        ret = cfdpDirectiveSubtypeCode_Encode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode condition_code */
	            ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode transaction_status */
	                ret = cfdpAckTransactionStatus_Encode((&(pVal->transaction_status)), pBitStrm, pErrCode, FALSE);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckPDU_Decode(cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode directive_code_of_ack_pdu */
	ret = cfdpDirectiveCode_Decode((&(pVal->directive_code_of_ack_pdu)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode directive_subtype_code */
	    ret = cfdpDirectiveSubtypeCode_Decode((&(pVal->directive_subtype_code)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode condition_code */
	        ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode transaction_status */
	            ret = cfdpAckTransactionStatus_Decode((&(pVal->transaction_status)), pBitStrm, pErrCode);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpAckPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpAckPDU_ACN_Encode(const cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal_directive_subtype_code;
	asn1SccUint intVal_pVal_condition_code;
	asn1SccUint intVal_pVal_transaction_status;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpAckPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode directive_code_of_ack_pdu */
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal->directive_code_of_ack_pdu);
	    if (ret) {
	        /*Encode directive_subtype_code */
	        switch(pVal->directive_subtype_code) {
	            case DirectiveSubtypeCode_ack_others:
	                intVal_pVal_directive_subtype_code = 0UL;
	                break;
	            case DirectiveSubtypeCode_ack_finished:
	                intVal_pVal_directive_subtype_code = 1UL;
	                break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_ENCODE_ACKPDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	        }
	        if (ret) {
	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_directive_subtype_code, 4);
	        }
	        if (ret) {
	            /*Encode condition_code */
	            switch(pVal->condition_code) {
	                case ConditionCode_no_error:
	                    intVal_pVal_condition_code = 0UL;
	                    break;
	                case ConditionCode_positive_ack_limit_reached:
	                    intVal_pVal_condition_code = 1UL;
	                    break;
	                case ConditionCode_keep_alive_limit_reached:
	                    intVal_pVal_condition_code = 2UL;
	                    break;
	                case ConditionCode_invalid_transmission_mode:
	                    intVal_pVal_condition_code = 3UL;
	                    break;
	                case ConditionCode_filestore_rejection:
	                    intVal_pVal_condition_code = 4UL;
	                    break;
	                case ConditionCode_file_checksum_failure:
	                    intVal_pVal_condition_code = 5UL;
	                    break;
	                case ConditionCode_file_size_error:
	                    intVal_pVal_condition_code = 6UL;
	                    break;
	                case ConditionCode_nak_limit_reached:
	                    intVal_pVal_condition_code = 7UL;
	                    break;
	                case ConditionCode_inactivity_detected:
	                    intVal_pVal_condition_code = 8UL;
	                    break;
	                case ConditionCode_invalid_file_structure:
	                    intVal_pVal_condition_code = 9UL;
	                    break;
	                case ConditionCode_check_limit_reached:
	                    intVal_pVal_condition_code = 10UL;
	                    break;
	                case ConditionCode_unsupported_checksum_type:
	                    intVal_pVal_condition_code = 11UL;
	                    break;
	                case ConditionCode_suspend_request_received:
	                    intVal_pVal_condition_code = 12UL;
	                    break;
	                case ConditionCode_cancel_request_received:
	                    intVal_pVal_condition_code = 13UL;
	                    break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_ACKPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_condition_code, 4);
	            }
	            if (ret) {
	                /*Encode AckPDU_spare */
	                {
	                	static byte tmp[] = {0x00};
	                	BitStream_AppendBits(pBitStrm, tmp, 2);
	                }
	                if (ret) {
	                    /*Encode transaction_status */
	                    switch(pVal->transaction_status) {
	                        case AckTransactionStatus_undefined:
	                            intVal_pVal_transaction_status = 0UL;
	                            break;
	                        case AckTransactionStatus_active:
	                            intVal_pVal_transaction_status = 1UL;
	                            break;
	                        case AckTransactionStatus_terminated:
	                            intVal_pVal_transaction_status = 2UL;
	                            break;
	                        case AckTransactionStatus_unrecognized:
	                            intVal_pVal_transaction_status = 3UL;
	                            break;
	                        default:                                    /*COVERAGE_IGNORE*/
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_ENCODE_ACKPDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	                    }
	                    if (ret) {
	                    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_transaction_status, 2);
	                    }
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpAckPDU_ACN_Decode(cfdpAckPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal_directive_subtype_code;
	asn1SccUint intVal_pVal_condition_code;
	asn1SccUint intVal_pVal_transaction_status;

	/*Decode directive_code_of_ack_pdu */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(pVal->directive_code_of_ack_pdu)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_DIRECTIVE_CODE_OF_ACK_PDU;
	if (ret) {
	    /*Decode directive_subtype_code */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_directive_subtype_code)), 4);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_DIRECTIVE_SUBTYPE_CODE;
	    if (ret) {
	        switch (intVal_pVal_directive_subtype_code) {
	            case 0:
	                pVal->directive_subtype_code = DirectiveSubtypeCode_ack_others;
	                break;
	            case 1:
	                pVal->directive_subtype_code = DirectiveSubtypeCode_ack_finished;
	                break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_DECODE_ACKPDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	        }
	    } /*COVERAGE_IGNORE*/
	    if (ret) {
	        /*Decode condition_code */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_condition_code)), 4);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_CONDITION_CODE;
	        if (ret) {
	            switch (intVal_pVal_condition_code) {
	                case 0:
	                    pVal->condition_code = ConditionCode_no_error;
	                    break;
	                case 1:
	                    pVal->condition_code = ConditionCode_positive_ack_limit_reached;
	                    break;
	                case 2:
	                    pVal->condition_code = ConditionCode_keep_alive_limit_reached;
	                    break;
	                case 3:
	                    pVal->condition_code = ConditionCode_invalid_transmission_mode;
	                    break;
	                case 4:
	                    pVal->condition_code = ConditionCode_filestore_rejection;
	                    break;
	                case 5:
	                    pVal->condition_code = ConditionCode_file_checksum_failure;
	                    break;
	                case 6:
	                    pVal->condition_code = ConditionCode_file_size_error;
	                    break;
	                case 7:
	                    pVal->condition_code = ConditionCode_nak_limit_reached;
	                    break;
	                case 8:
	                    pVal->condition_code = ConditionCode_inactivity_detected;
	                    break;
	                case 9:
	                    pVal->condition_code = ConditionCode_invalid_file_structure;
	                    break;
	                case 10:
	                    pVal->condition_code = ConditionCode_check_limit_reached;
	                    break;
	                case 11:
	                    pVal->condition_code = ConditionCode_unsupported_checksum_type;
	                    break;
	                case 12:
	                    pVal->condition_code = ConditionCode_suspend_request_received;
	                    break;
	                case 13:
	                    pVal->condition_code = ConditionCode_cancel_request_received;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_ACKPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode AckPDU_spare */
	            {
	            	static byte tmp[] = {0x00};
	                flag bDecodingPatternMatches;
	            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                ret = ret && bDecodingPatternMatches;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_SPARE;
	            }

	            if (ret) {
	                /*Decode transaction_status */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_transaction_status)), 2);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_ACKPDU_TRANSACTION_STATUS;
	                if (ret) {
	                    switch (intVal_pVal_transaction_status) {
	                        case 0:
	                            pVal->transaction_status = AckTransactionStatus_undefined;
	                            break;
	                        case 1:
	                            pVal->transaction_status = AckTransactionStatus_active;
	                            break;
	                        case 2:
	                            pVal->transaction_status = AckTransactionStatus_terminated;
	                            break;
	                        case 3:
	                            pVal->transaction_status = AckTransactionStatus_unrecognized;
	                            break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_ACKPDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	                    }
	                } /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpAckPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDeliveryCode_Equal(const cfdpDeliveryCode* pVal1, const cfdpDeliveryCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDeliveryCode_IsConstraintValid(const cfdpDeliveryCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == DeliveryCode_data_complete)) || (((*(pVal)) == DeliveryCode_data_incomplete)));
    *pErrCode = ret ? 0 :  ERR_DELIVERYCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpDeliveryCode cfdpDeliveryCode_constant = DeliveryCode_data_complete;
#endif

void cfdpDeliveryCode_Initialize(cfdpDeliveryCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDeliveryCode)cfdpDeliveryCode_constant;
}

flag cfdpDeliveryCode_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case DeliveryCode_data_complete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case DeliveryCode_data_incomplete:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DELIVERYCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DELIVERYCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = DeliveryCode_data_complete;
	                break;
	            case 1:
	                (*(pVal)) = DeliveryCode_data_incomplete;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DELIVERYCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = DeliveryCode_data_complete;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDeliveryCode_ACN_Encode(const cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case DeliveryCode_data_complete:
	            intVal_pVal = 0UL;
	            break;
	        case DeliveryCode_data_incomplete:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDeliveryCode_ACN_Decode(cfdpDeliveryCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DELIVERYCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = DeliveryCode_data_complete;
	            break;
	        case 1:
	            (*(pVal)) = DeliveryCode_data_incomplete;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DELIVERYCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDeliveryCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpClosureRequested_Equal(const cfdpClosureRequested* pVal1, const cfdpClosureRequested* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpClosureRequested_IsConstraintValid(const cfdpClosureRequested* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == ClosureRequested_requested)) || (((*(pVal)) == ClosureRequested_not_requested)));
    *pErrCode = ret ? 0 :  ERR_CLOSUREREQUESTED;

	return ret;
}

#ifdef __cplusplus
const cfdpClosureRequested cfdpClosureRequested_constant = ClosureRequested_requested;
#endif

void cfdpClosureRequested_Initialize(cfdpClosureRequested* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpClosureRequested)cfdpClosureRequested_constant;
}

flag cfdpClosureRequested_Encode(const cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpClosureRequested_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ClosureRequested_requested:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case ClosureRequested_not_requested:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CLOSUREREQUESTED; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpClosureRequested_Decode(cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CLOSUREREQUESTED;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ClosureRequested_requested;
	                break;
	            case 1:
	                (*(pVal)) = ClosureRequested_not_requested;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CLOSUREREQUESTED;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ClosureRequested_requested;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpClosureRequested_IsConstraintValid(pVal, pErrCode);
}

flag cfdpClosureRequested_ACN_Encode(const cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpClosureRequested_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ClosureRequested_requested:
	            intVal_pVal = 0UL;
	            break;
	        case ClosureRequested_not_requested:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CLOSUREREQUESTED;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpClosureRequested_ACN_Decode(cfdpClosureRequested* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CLOSUREREQUESTED;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ClosureRequested_requested;
	            break;
	        case 1:
	            (*(pVal)) = ClosureRequested_not_requested;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CLOSUREREQUESTED;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpClosureRequested_IsConstraintValid(pVal, pErrCode);
}


flag cfdpChecksumType_Equal(const cfdpChecksumType* pVal1, const cfdpChecksumType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpChecksumType_IsConstraintValid(const cfdpChecksumType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == ChecksumType_modular)) || (((*(pVal)) == ChecksumType_none)));
    *pErrCode = ret ? 0 :  ERR_CHECKSUMTYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpChecksumType cfdpChecksumType_constant = ChecksumType_modular;
#endif

void cfdpChecksumType_Initialize(cfdpChecksumType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpChecksumType)cfdpChecksumType_constant;
}

flag cfdpChecksumType_Encode(const cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpChecksumType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ChecksumType_modular:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case ChecksumType_none:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CHECKSUMTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpChecksumType_Decode(cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CHECKSUMTYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ChecksumType_modular;
	                break;
	            case 1:
	                (*(pVal)) = ChecksumType_none;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CHECKSUMTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ChecksumType_modular;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpChecksumType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpChecksumType_ACN_Encode(const cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpChecksumType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ChecksumType_modular:
	            intVal_pVal = 0UL;
	            break;
	        case ChecksumType_none:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CHECKSUMTYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 4);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpChecksumType_ACN_Decode(cfdpChecksumType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CHECKSUMTYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ChecksumType_modular;
	            break;
	        case 1:
	            (*(pVal)) = ChecksumType_none;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CHECKSUMTYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpChecksumType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileNameSize_Equal(const cfdpFileNameSize* pVal1, const cfdpFileNameSize* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileNameSize_IsConstraintValid(const cfdpFileNameSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 128UL);
    *pErrCode = ret ? 0 :  ERR_FILENAMESIZE;

	return ret;
}

#ifdef __cplusplus
const cfdpFileNameSize cfdpFileNameSize_constant = 0UL;
#endif

void cfdpFileNameSize_Initialize(cfdpFileNameSize* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileNameSize)cfdpFileNameSize_constant;
}

flag cfdpFileNameSize_Encode(const cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileNameSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 128);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileNameSize_Decode(cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 128);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILENAMESIZE;

	return ret  && cfdpFileNameSize_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileNameSize_ACN_Encode(const cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileNameSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileNameSize_ACN_Decode(cfdpFileNameSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILENAMESIZE;

    return ret && cfdpFileNameSize_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileName_Equal(const cfdpFileName* pVal1, const cfdpFileName* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpFileName_IsConstraintValid(const cfdpFileName* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 128);
    *pErrCode = ret ? 0 :  ERR_FILENAME;

	return ret;
}

#ifdef __cplusplus
const cfdpFileName cfdpFileName_constant = {.nCount = 0, .arr  = {[0 ... 128-1] = 0 }};
#endif

void cfdpFileName_Initialize(cfdpFileName* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileName)cfdpFileName_constant;
}

flag cfdpFileName_Encode(const cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 128);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileName_Decode(cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 128);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILENAME;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpFileName_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileName_ACN_Encode(const cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 128);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileName_ACN_Decode(cfdpFileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 128);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILENAME;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpFileName_IsConstraintValid(pVal, pErrCode);
}


flag cfdpMetadataPDU_Equal(const cfdpMetadataPDU* pVal1, const cfdpMetadataPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->closure_requested == pVal2->closure_requested);

    if (ret) {
        ret = (pVal1->checksum_type == pVal2->checksum_type);

        if (ret) {
            ret = (pVal1->file_size == pVal2->file_size);

            if (ret) {
                ret = cfdpFileName_Equal((&(pVal1->source_file_name)), (&(pVal2->source_file_name)));

                if (ret) {
                    ret = cfdpFileName_Equal((&(pVal1->destination_file_name)), (&(pVal2->destination_file_name)));

                }

            }

        }

    }

	return ret;

}

flag cfdpMetadataPDU_IsConstraintValid(const cfdpMetadataPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpClosureRequested_IsConstraintValid((&(pVal->closure_requested)), pErrCode);
    if (ret) {
        ret = cfdpChecksumType_IsConstraintValid((&(pVal->checksum_type)), pErrCode);
        if (ret) {
            ret = cfdpFileSize_IsConstraintValid((&(pVal->file_size)), pErrCode);
            if (ret) {
                ret = cfdpFileName_IsConstraintValid((&(pVal->source_file_name)), pErrCode);
                if (ret) {
                    ret = cfdpFileName_IsConstraintValid((&(pVal->destination_file_name)), pErrCode);
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpMetadataPDU cfdpMetadataPDU_constant = {.closure_requested = ClosureRequested_requested, .checksum_type = ChecksumType_modular, .file_size = 0UL, .source_file_name = {.nCount = 0, .arr  = {[0 ... 128-1] = 0 }}, .destination_file_name = {.nCount = 0, .arr  = {[0 ... 128-1] = 0 }}};
#endif

void cfdpMetadataPDU_Initialize(cfdpMetadataPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpMetadataPDU)cfdpMetadataPDU_constant;
}

flag cfdpMetadataPDU_Encode(const cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode closure_requested */
	    ret = cfdpClosureRequested_Encode((&(pVal->closure_requested)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode checksum_type */
	        ret = cfdpChecksumType_Encode((&(pVal->checksum_type)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_size */
	            ret = cfdpFileSize_Encode((&(pVal->file_size)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode source_file_name */
	                ret = cfdpFileName_Encode((&(pVal->source_file_name)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode destination_file_name */
	                    ret = cfdpFileName_Encode((&(pVal->destination_file_name)), pBitStrm, pErrCode, FALSE);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMetadataPDU_Decode(cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode closure_requested */
	ret = cfdpClosureRequested_Decode((&(pVal->closure_requested)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode checksum_type */
	    ret = cfdpChecksumType_Decode((&(pVal->checksum_type)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_size */
	        ret = cfdpFileSize_Decode((&(pVal->file_size)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode source_file_name */
	            ret = cfdpFileName_Decode((&(pVal->source_file_name)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode destination_file_name */
	                ret = cfdpFileName_Decode((&(pVal->destination_file_name)), pBitStrm, pErrCode);
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpMetadataPDU_ACN_Encode(const cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint MetadataPDU_source_file_name_size;
	flag MetadataPDU_source_file_name_size_is_initialized=FALSE;
	asn1SccUint MetadataPDU_destination_file_name_size;
	flag MetadataPDU_destination_file_name_size_is_initialized=FALSE;
	asn1SccUint intVal_pVal_closure_requested;
	asn1SccUint intVal_pVal_checksum_type;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode MetadataPDU_reserved1 */
	    {
	    	static byte tmp[] = {0x00};
	    	BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
	    if (ret) {
	        /*Encode closure_requested */
	        switch(pVal->closure_requested) {
	            case ClosureRequested_requested:
	                intVal_pVal_closure_requested = 0UL;
	                break;
	            case ClosureRequested_not_requested:
	                intVal_pVal_closure_requested = 1UL;
	                break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_ENCODE_METADATAPDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	        }
	        if (ret) {
	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_closure_requested, 1);
	        }
	        if (ret) {
	            /*Encode MetadataPDU_reserved2 */
	            {
	            	static byte tmp[] = {0x00};
	            	BitStream_AppendBits(pBitStrm, tmp, 2);
	            }
	            if (ret) {
	                /*Encode checksum_type */
	                switch(pVal->checksum_type) {
	                    case ChecksumType_modular:
	                        intVal_pVal_checksum_type = 0UL;
	                        break;
	                    case ChecksumType_none:
	                        intVal_pVal_checksum_type = 1UL;
	                        break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_ENCODE_METADATAPDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	                }
	                if (ret) {
	                	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_checksum_type, 4);
	                }
	                if (ret) {
	                    /*Encode file_size */
	                    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_size);
	                    if (ret) {
	                        MetadataPDU_source_file_name_size_is_initialized = TRUE;
	                        MetadataPDU_source_file_name_size = pVal->source_file_name.nCount;
	                        if (ret) {
	                            /*Encode MetadataPDU_source_file_name_size */
	                            if (MetadataPDU_source_file_name_size_is_initialized) {
	                                ret = TRUE;
	                                Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, MetadataPDU_source_file_name_size);
	                            } else {
	                                *pErrCode = ERR_ACN_ENCODE_METADATAPDU_SOURCE_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                ret = FALSE;                    /*COVERAGE_IGNORE*/
	                            }
	                        }   /*COVERAGE_IGNORE*/
	                        if (ret) {
	                            /*Encode source_file_name */
	                            ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->source_file_name.arr, pVal->source_file_name.nCount);
	                            if (ret) {
	                                MetadataPDU_destination_file_name_size_is_initialized = TRUE;
	                                MetadataPDU_destination_file_name_size = pVal->destination_file_name.nCount;
	                                if (ret) {
	                                    /*Encode MetadataPDU_destination_file_name_size */
	                                    if (MetadataPDU_destination_file_name_size_is_initialized) {
	                                        ret = TRUE;
	                                        Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, MetadataPDU_destination_file_name_size);
	                                    } else {
	                                        *pErrCode = ERR_ACN_ENCODE_METADATAPDU_DESTINATION_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                        ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                    }
	                                }   /*COVERAGE_IGNORE*/
	                                if (ret) {
	                                    /*Encode destination_file_name */
	                                    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->destination_file_name.arr, pVal->destination_file_name.nCount);
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMetadataPDU_ACN_Decode(cfdpMetadataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint MetadataPDU_source_file_name_size;
	asn1SccUint MetadataPDU_destination_file_name_size;
	asn1SccUint intVal_pVal_closure_requested;
	asn1SccUint intVal_pVal_checksum_type;

	/*Decode MetadataPDU_reserved1 */
	{
		static byte tmp[] = {0x00};
	    flag bDecodingPatternMatches;
		ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	    ret = ret && bDecodingPatternMatches;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_RESERVED1;
	}

	if (ret) {
	    /*Decode closure_requested */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_closure_requested)), 1);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_CLOSURE_REQUESTED;
	    if (ret) {
	        switch (intVal_pVal_closure_requested) {
	            case 0:
	                pVal->closure_requested = ClosureRequested_requested;
	                break;
	            case 1:
	                pVal->closure_requested = ClosureRequested_not_requested;
	                break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_DECODE_METADATAPDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	        }
	    } /*COVERAGE_IGNORE*/
	    if (ret) {
	        /*Decode MetadataPDU_reserved2 */
	        {
	        	static byte tmp[] = {0x00};
	            flag bDecodingPatternMatches;
	        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	            ret = ret && bDecodingPatternMatches;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_RESERVED2;
	        }

	        if (ret) {
	            /*Decode checksum_type */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_checksum_type)), 4);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_CHECKSUM_TYPE;
	            if (ret) {
	                switch (intVal_pVal_checksum_type) {
	                    case 0:
	                        pVal->checksum_type = ChecksumType_modular;
	                        break;
	                    case 1:
	                        pVal->checksum_type = ChecksumType_none;
	                        break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_METADATAPDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	                }
	            } /*COVERAGE_IGNORE*/
	            if (ret) {
	                /*Decode file_size */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_size)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_FILE_SIZE;
	                if (ret) {
	                    /*Decode MetadataPDU_source_file_name_size */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(MetadataPDU_source_file_name_size)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_SOURCE_FILE_NAME_SIZE;
	                    if (ret) {
	                        /*Decode source_file_name */
	                        ret = ((MetadataPDU_source_file_name_size<=128));
	                        if (ret) {
	                            pVal->source_file_name.nCount = (int)MetadataPDU_source_file_name_size;
	                            ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->source_file_name.arr, pVal->source_file_name.nCount);
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_SOURCE_FILE_NAME;
	                        }
	                        if (ret) {
	                            /*Decode MetadataPDU_destination_file_name_size */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(MetadataPDU_destination_file_name_size)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_DESTINATION_FILE_NAME_SIZE;
	                            if (ret) {
	                                /*Decode destination_file_name */
	                                ret = ((MetadataPDU_destination_file_name_size<=128));
	                                if (ret) {
	                                    pVal->destination_file_name.nCount = (int)MetadataPDU_destination_file_name_size;
	                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->destination_file_name.arr, pVal->destination_file_name.nCount);
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_METADATAPDU_DESTINATION_FILE_NAME;
	                                }
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpMetadataPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileStatus_Equal(const cfdpFileStatus* pVal1, const cfdpFileStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpFileStatus_IsConstraintValid(const cfdpFileStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == FileStatus_discarted_deliberately)) || (((*(pVal)) == FileStatus_discarted_file_rejection)))) || (((*(pVal)) == FileStatus_retained_successfully)))) || (((*(pVal)) == FileStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_FILESTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpFileStatus cfdpFileStatus_constant = FileStatus_discarted_deliberately;
#endif

void cfdpFileStatus_Initialize(cfdpFileStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileStatus)cfdpFileStatus_constant;
}

flag cfdpFileStatus_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case FileStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case FileStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case FileStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case FileStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_FILESTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_FILESTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = FileStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = FileStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = FileStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = FileStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_FILESTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = FileStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileStatus_ACN_Encode(const cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case FileStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case FileStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case FileStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case FileStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileStatus_ACN_Decode(cfdpFileStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILESTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = FileStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = FileStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = FileStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = FileStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_FILESTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpFileStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFinishedPDU_Equal(const cfdpFinishedPDU* pVal1, const cfdpFinishedPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->condition_code == pVal2->condition_code);

    if (ret) {
        ret = (pVal1->delivery_code == pVal2->delivery_code);

        if (ret) {
            ret = (pVal1->file_status == pVal2->file_status);

        }

    }

	return ret;

}

flag cfdpFinishedPDU_IsConstraintValid(const cfdpFinishedPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpConditionCode_IsConstraintValid((&(pVal->condition_code)), pErrCode);
    if (ret) {
        ret = cfdpDeliveryCode_IsConstraintValid((&(pVal->delivery_code)), pErrCode);
        if (ret) {
            ret = cfdpFileStatus_IsConstraintValid((&(pVal->file_status)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpFinishedPDU cfdpFinishedPDU_constant = {.condition_code = ConditionCode_no_error, .delivery_code = DeliveryCode_data_complete, .file_status = FileStatus_discarted_deliberately};
#endif

void cfdpFinishedPDU_Initialize(cfdpFinishedPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFinishedPDU)cfdpFinishedPDU_constant;
}

flag cfdpFinishedPDU_Encode(const cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    ret = cfdpConditionCode_Encode((&(pVal->condition_code)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode delivery_code */
	        ret = cfdpDeliveryCode_Encode((&(pVal->delivery_code)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode file_status */
	            ret = cfdpFileStatus_Encode((&(pVal->file_status)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFinishedPDU_Decode(cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode condition_code */
	ret = cfdpConditionCode_Decode((&(pVal->condition_code)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode delivery_code */
	    ret = cfdpDeliveryCode_Decode((&(pVal->delivery_code)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode file_status */
	        ret = cfdpFileStatus_Decode((&(pVal->file_status)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFinishedPDU_ACN_Encode(const cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal_condition_code;
	asn1SccUint intVal_pVal_delivery_code;
	asn1SccUint intVal_pVal_file_status;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode condition_code */
	    switch(pVal->condition_code) {
	        case ConditionCode_no_error:
	            intVal_pVal_condition_code = 0UL;
	            break;
	        case ConditionCode_positive_ack_limit_reached:
	            intVal_pVal_condition_code = 1UL;
	            break;
	        case ConditionCode_keep_alive_limit_reached:
	            intVal_pVal_condition_code = 2UL;
	            break;
	        case ConditionCode_invalid_transmission_mode:
	            intVal_pVal_condition_code = 3UL;
	            break;
	        case ConditionCode_filestore_rejection:
	            intVal_pVal_condition_code = 4UL;
	            break;
	        case ConditionCode_file_checksum_failure:
	            intVal_pVal_condition_code = 5UL;
	            break;
	        case ConditionCode_file_size_error:
	            intVal_pVal_condition_code = 6UL;
	            break;
	        case ConditionCode_nak_limit_reached:
	            intVal_pVal_condition_code = 7UL;
	            break;
	        case ConditionCode_inactivity_detected:
	            intVal_pVal_condition_code = 8UL;
	            break;
	        case ConditionCode_invalid_file_structure:
	            intVal_pVal_condition_code = 9UL;
	            break;
	        case ConditionCode_check_limit_reached:
	            intVal_pVal_condition_code = 10UL;
	            break;
	        case ConditionCode_unsupported_checksum_type:
	            intVal_pVal_condition_code = 11UL;
	            break;
	        case ConditionCode_suspend_request_received:
	            intVal_pVal_condition_code = 12UL;
	            break;
	        case ConditionCode_cancel_request_received:
	            intVal_pVal_condition_code = 13UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_FINISHEDPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_condition_code, 4);
	    }
	    if (ret) {
	        /*Encode FinishedPDU_end_system_status */
	        {
	        	static byte tmp[] = {0x80};
	        	BitStream_AppendBits(pBitStrm, tmp, 1);
	        }
	        if (ret) {
	            /*Encode delivery_code */
	            switch(pVal->delivery_code) {
	                case DeliveryCode_data_complete:
	                    intVal_pVal_delivery_code = 0UL;
	                    break;
	                case DeliveryCode_data_incomplete:
	                    intVal_pVal_delivery_code = 1UL;
	                    break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_FINISHEDPDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_delivery_code, 1);
	            }
	            if (ret) {
	                /*Encode file_status */
	                switch(pVal->file_status) {
	                    case FileStatus_discarted_deliberately:
	                        intVal_pVal_file_status = 0UL;
	                        break;
	                    case FileStatus_discarted_file_rejection:
	                        intVal_pVal_file_status = 1UL;
	                        break;
	                    case FileStatus_retained_successfully:
	                        intVal_pVal_file_status = 2UL;
	                        break;
	                    case FileStatus_unreported:
	                        intVal_pVal_file_status = 3UL;
	                        break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_ENCODE_FINISHEDPDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	                }
	                if (ret) {
	                	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_status, 2);
	                }
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFinishedPDU_ACN_Decode(cfdpFinishedPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal_condition_code;
	asn1SccUint intVal_pVal_delivery_code;
	asn1SccUint intVal_pVal_file_status;

	/*Decode condition_code */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_condition_code)), 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FINISHEDPDU_CONDITION_CODE;
	if (ret) {
	    switch (intVal_pVal_condition_code) {
	        case 0:
	            pVal->condition_code = ConditionCode_no_error;
	            break;
	        case 1:
	            pVal->condition_code = ConditionCode_positive_ack_limit_reached;
	            break;
	        case 2:
	            pVal->condition_code = ConditionCode_keep_alive_limit_reached;
	            break;
	        case 3:
	            pVal->condition_code = ConditionCode_invalid_transmission_mode;
	            break;
	        case 4:
	            pVal->condition_code = ConditionCode_filestore_rejection;
	            break;
	        case 5:
	            pVal->condition_code = ConditionCode_file_checksum_failure;
	            break;
	        case 6:
	            pVal->condition_code = ConditionCode_file_size_error;
	            break;
	        case 7:
	            pVal->condition_code = ConditionCode_nak_limit_reached;
	            break;
	        case 8:
	            pVal->condition_code = ConditionCode_inactivity_detected;
	            break;
	        case 9:
	            pVal->condition_code = ConditionCode_invalid_file_structure;
	            break;
	        case 10:
	            pVal->condition_code = ConditionCode_check_limit_reached;
	            break;
	        case 11:
	            pVal->condition_code = ConditionCode_unsupported_checksum_type;
	            break;
	        case 12:
	            pVal->condition_code = ConditionCode_suspend_request_received;
	            break;
	        case 13:
	            pVal->condition_code = ConditionCode_cancel_request_received;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_FINISHEDPDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode FinishedPDU_end_system_status */
	    {
	    	static byte tmp[] = {0x80};
	        flag bDecodingPatternMatches;
	    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	        ret = ret && bDecodingPatternMatches;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FINISHEDPDU_END_SYSTEM_STATUS;
	    }

	    if (ret) {
	        /*Decode delivery_code */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_delivery_code)), 1);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FINISHEDPDU_DELIVERY_CODE;
	        if (ret) {
	            switch (intVal_pVal_delivery_code) {
	                case 0:
	                    pVal->delivery_code = DeliveryCode_data_complete;
	                    break;
	                case 1:
	                    pVal->delivery_code = DeliveryCode_data_incomplete;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_FINISHEDPDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode file_status */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_status)), 2);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_FINISHEDPDU_FILE_STATUS;
	            if (ret) {
	                switch (intVal_pVal_file_status) {
	                    case 0:
	                        pVal->file_status = FileStatus_discarted_deliberately;
	                        break;
	                    case 1:
	                        pVal->file_status = FileStatus_discarted_file_rejection;
	                        break;
	                    case 2:
	                        pVal->file_status = FileStatus_retained_successfully;
	                        break;
	                    case 3:
	                        pVal->file_status = FileStatus_unreported;
	                        break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_FINISHEDPDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	                }
	            } /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpFinishedPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileDirectivePDU_Equal(const cfdpFileDirectivePDU* pVal1, const cfdpFileDirectivePDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind)
    	{
    	case FileDirectivePDU_eof_pdu_PRESENT:
    		ret = cfdpEofPDU_Equal((&(pVal1->u.eof_pdu)), (&(pVal2->u.eof_pdu)));
    		break;
    	case FileDirectivePDU_finished_pdu_PRESENT:
    		ret = cfdpFinishedPDU_Equal((&(pVal1->u.finished_pdu)), (&(pVal2->u.finished_pdu)));
    		break;
    	case FileDirectivePDU_ack_pdu_PRESENT:
    		ret = cfdpAckPDU_Equal((&(pVal1->u.ack_pdu)), (&(pVal2->u.ack_pdu)));
    		break;
    	case FileDirectivePDU_metadata_pdu_PRESENT:
    		ret = cfdpMetadataPDU_Equal((&(pVal1->u.metadata_pdu)), (&(pVal2->u.metadata_pdu)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag cfdpFileDirectivePDU_IsConstraintValid(const cfdpFileDirectivePDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    switch (pVal->kind) {
        case FileDirectivePDU_eof_pdu_PRESENT : 
            ret = cfdpEofPDU_IsConstraintValid((&(pVal->u.eof_pdu)), pErrCode);
            break;          
        case FileDirectivePDU_finished_pdu_PRESENT : 
            ret = cfdpFinishedPDU_IsConstraintValid((&(pVal->u.finished_pdu)), pErrCode);
            break;          
        case FileDirectivePDU_ack_pdu_PRESENT : 
            ret = cfdpAckPDU_IsConstraintValid((&(pVal->u.ack_pdu)), pErrCode);
            break;          
        case FileDirectivePDU_metadata_pdu_PRESENT : 
            ret = cfdpMetadataPDU_IsConstraintValid((&(pVal->u.metadata_pdu)), pErrCode);
            break;          
        default: /*COVERAGE_IGNORE*/
    	    *pErrCode = ERR_FILEDIRECTIVEPDU;      /*COVERAGE_IGNORE*/
    	    ret = FALSE;                               /*COVERAGE_IGNORE*/
    }

	return ret;
}

#ifdef __cplusplus
const cfdpFileDirectivePDU cfdpFileDirectivePDU_constant = {.kind = FileDirectivePDU_eof_pdu_PRESENT, .u.eof_pdu = cfdpEofPDU_constant};
#endif

void cfdpFileDirectivePDU_Initialize(cfdpFileDirectivePDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileDirectivePDU)cfdpFileDirectivePDU_constant;
}

flag cfdpFileDirectivePDU_Encode(const cfdpFileDirectivePDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDirectivePDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind)
	    {
	    case FileDirectivePDU_eof_pdu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = cfdpEofPDU_Encode((&(pVal->u.eof_pdu)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case FileDirectivePDU_finished_pdu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = cfdpFinishedPDU_Encode((&(pVal->u.finished_pdu)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case FileDirectivePDU_ack_pdu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = cfdpAckPDU_Encode((&(pVal->u.ack_pdu)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case FileDirectivePDU_metadata_pdu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = cfdpMetadataPDU_Encode((&(pVal->u.metadata_pdu)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_FILEDIRECTIVEPDU;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDirectivePDU_Decode(cfdpFileDirectivePDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint cfdpFileDirectivePDU_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &cfdpFileDirectivePDU_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILEDIRECTIVEPDU;
	if (ret) {
	    switch(cfdpFileDirectivePDU_index_tmp)
	    {
	    case 0:
	    	pVal->kind = FileDirectivePDU_eof_pdu_PRESENT;
	    	ret = cfdpEofPDU_Decode((&(pVal->u.eof_pdu)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = FileDirectivePDU_finished_pdu_PRESENT;
	    	ret = cfdpFinishedPDU_Decode((&(pVal->u.finished_pdu)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = FileDirectivePDU_ack_pdu_PRESENT;
	    	ret = cfdpAckPDU_Decode((&(pVal->u.ack_pdu)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = FileDirectivePDU_metadata_pdu_PRESENT;
	    	ret = cfdpMetadataPDU_Decode((&(pVal->u.metadata_pdu)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_FILEDIRECTIVEPDU;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && cfdpFileDirectivePDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileDirectiveType_Equal(const cfdpFileDirectiveType* pVal1, const cfdpFileDirectiveType* pVal2)
{
	flag ret=TRUE;

    ret = cfdpFileDirectivePDU_Equal((&(pVal1->file_directive_pdu)), (&(pVal2->file_directive_pdu)));

	return ret;

}

flag cfdpFileDirectiveType_IsConstraintValid(const cfdpFileDirectiveType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpFileDirectivePDU_IsConstraintValid((&(pVal->file_directive_pdu)), pErrCode);

	return ret;
}

#ifdef __cplusplus
const cfdpFileDirectiveType cfdpFileDirectiveType_constant = {.file_directive_pdu = cfdpFileDirectivePDU_constant};
#endif

void cfdpFileDirectiveType_Initialize(cfdpFileDirectiveType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileDirectiveType)cfdpFileDirectiveType_constant;
}

flag cfdpFileDirectiveType_Encode(const cfdpFileDirectiveType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDirectiveType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode file_directive_pdu */
	    ret = cfdpFileDirectivePDU_Encode((&(pVal->file_directive_pdu)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDirectiveType_Decode(cfdpFileDirectiveType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode file_directive_pdu */
	ret = cfdpFileDirectivePDU_Decode((&(pVal->file_directive_pdu)), pBitStrm, pErrCode);

	return ret  && cfdpFileDirectiveType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileDirectiveType_ACN_Encode(const cfdpFileDirectiveType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint FileDirectiveType_directive_code;
	flag FileDirectiveType_directive_code_is_initialized=FALSE;
	asn1SccUint intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_file_status;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status;
	asn1SccUint FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size;
	flag FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized=FALSE;
	asn1SccUint FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size;
	flag FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized=FALSE;
	asn1SccUint intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested;
	asn1SccUint intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDirectiveType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch (pVal->file_directive_pdu.kind) {
	        case FileDirectivePDU_eof_pdu_PRESENT:
	        		FileDirectiveType_directive_code_is_initialized = TRUE;
	        		FileDirectiveType_directive_code = 4;
	            break;
	        case FileDirectivePDU_finished_pdu_PRESENT:
	        		FileDirectiveType_directive_code_is_initialized = TRUE;
	        		FileDirectiveType_directive_code = 5;
	            break;
	        case FileDirectivePDU_ack_pdu_PRESENT:
	        		FileDirectiveType_directive_code_is_initialized = TRUE;
	        		FileDirectiveType_directive_code = 6;
	            break;
	        case FileDirectivePDU_metadata_pdu_PRESENT:
	        		FileDirectiveType_directive_code_is_initialized = TRUE;
	        		FileDirectiveType_directive_code = 7;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode FileDirectiveType_directive_code */
	        if (FileDirectiveType_directive_code_is_initialized) {
	            ret = TRUE;
	            Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, FileDirectiveType_directive_code);
	        } else {
	            *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_DIRECTIVE_CODE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        }
	    }   /*COVERAGE_IGNORE*/
	    if (ret) {
	        /*Encode file_directive_pdu */
	        switch(pVal->file_directive_pdu.kind)
	        {
	        case FileDirectivePDU_eof_pdu_PRESENT:
	        	/*Encode condition_code */
	        	switch(pVal->file_directive_pdu.u.eof_pdu.condition_code) {
	        	    case ConditionCode_no_error:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 0UL;
	        	        break;
	        	    case ConditionCode_positive_ack_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 1UL;
	        	        break;
	        	    case ConditionCode_keep_alive_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 2UL;
	        	        break;
	        	    case ConditionCode_invalid_transmission_mode:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 3UL;
	        	        break;
	        	    case ConditionCode_filestore_rejection:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 4UL;
	        	        break;
	        	    case ConditionCode_file_checksum_failure:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 5UL;
	        	        break;
	        	    case ConditionCode_file_size_error:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 6UL;
	        	        break;
	        	    case ConditionCode_nak_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 7UL;
	        	        break;
	        	    case ConditionCode_inactivity_detected:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 8UL;
	        	        break;
	        	    case ConditionCode_invalid_file_structure:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 9UL;
	        	        break;
	        	    case ConditionCode_check_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 10UL;
	        	        break;
	        	    case ConditionCode_unsupported_checksum_type:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 11UL;
	        	        break;
	        	    case ConditionCode_suspend_request_received:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 12UL;
	        	        break;
	        	    case ConditionCode_cancel_request_received:
	        	        intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code = 13UL;
	        	        break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	        	}
	        	if (ret) {
	        		Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code, 4);
	        	}
	        	if (ret) {
	        	    /*Encode FileDirectiveType_file_directive_pdu_eof_pdu_spare */
	        	    {
	        	    	static byte tmp[] = {0x00};
	        	    	BitStream_AppendBits(pBitStrm, tmp, 4);
	        	    }
	        	    if (ret) {
	        	        /*Encode file_checksum */
	        	        Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_directive_pdu.u.eof_pdu.file_checksum);
	        	        if (ret) {
	        	            /*Encode file_size */
	        	            Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_directive_pdu.u.eof_pdu.file_size);
	        	        }   /*COVERAGE_IGNORE*/
	        	    }   /*COVERAGE_IGNORE*/
	        	}   /*COVERAGE_IGNORE*/
	        	break;
	        case FileDirectivePDU_finished_pdu_PRESENT:
	        	/*Encode condition_code */
	        	switch(pVal->file_directive_pdu.u.finished_pdu.condition_code) {
	        	    case ConditionCode_no_error:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 0UL;
	        	        break;
	        	    case ConditionCode_positive_ack_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 1UL;
	        	        break;
	        	    case ConditionCode_keep_alive_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 2UL;
	        	        break;
	        	    case ConditionCode_invalid_transmission_mode:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 3UL;
	        	        break;
	        	    case ConditionCode_filestore_rejection:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 4UL;
	        	        break;
	        	    case ConditionCode_file_checksum_failure:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 5UL;
	        	        break;
	        	    case ConditionCode_file_size_error:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 6UL;
	        	        break;
	        	    case ConditionCode_nak_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 7UL;
	        	        break;
	        	    case ConditionCode_inactivity_detected:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 8UL;
	        	        break;
	        	    case ConditionCode_invalid_file_structure:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 9UL;
	        	        break;
	        	    case ConditionCode_check_limit_reached:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 10UL;
	        	        break;
	        	    case ConditionCode_unsupported_checksum_type:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 11UL;
	        	        break;
	        	    case ConditionCode_suspend_request_received:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 12UL;
	        	        break;
	        	    case ConditionCode_cancel_request_received:
	        	        intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code = 13UL;
	        	        break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	        	}
	        	if (ret) {
	        		Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code, 4);
	        	}
	        	if (ret) {
	        	    /*Encode FileDirectiveType_file_directive_pdu_finished_pdu_end_system_status */
	        	    {
	        	    	static byte tmp[] = {0x80};
	        	    	BitStream_AppendBits(pBitStrm, tmp, 1);
	        	    }
	        	    if (ret) {
	        	        /*Encode delivery_code */
	        	        switch(pVal->file_directive_pdu.u.finished_pdu.delivery_code) {
	        	            case DeliveryCode_data_complete:
	        	                intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code = 0UL;
	        	                break;
	        	            case DeliveryCode_data_incomplete:
	        	                intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code = 1UL;
	        	                break;
	        	            default:                                    /*COVERAGE_IGNORE*/
	        	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	                *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	        	        }
	        	        if (ret) {
	        	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code, 1);
	        	        }
	        	        if (ret) {
	        	            /*Encode file_status */
	        	            switch(pVal->file_directive_pdu.u.finished_pdu.file_status) {
	        	                case FileStatus_discarted_deliberately:
	        	                    intVal_pVal_file_directive_pdu_u_finished_pdu_file_status = 0UL;
	        	                    break;
	        	                case FileStatus_discarted_file_rejection:
	        	                    intVal_pVal_file_directive_pdu_u_finished_pdu_file_status = 1UL;
	        	                    break;
	        	                case FileStatus_retained_successfully:
	        	                    intVal_pVal_file_directive_pdu_u_finished_pdu_file_status = 2UL;
	        	                    break;
	        	                case FileStatus_unreported:
	        	                    intVal_pVal_file_directive_pdu_u_finished_pdu_file_status = 3UL;
	        	                    break;
	        	                default:                                    /*COVERAGE_IGNORE*/
	        	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	                    *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	        	            }
	        	            if (ret) {
	        	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_finished_pdu_file_status, 2);
	        	            }
	        	        }   /*COVERAGE_IGNORE*/
	        	    }   /*COVERAGE_IGNORE*/
	        	}   /*COVERAGE_IGNORE*/
	        	break;
	        case FileDirectivePDU_ack_pdu_PRESENT:
	        	/*Encode directive_code_of_ack_pdu */
	        	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal->file_directive_pdu.u.ack_pdu.directive_code_of_ack_pdu);
	        	if (ret) {
	        	    /*Encode directive_subtype_code */
	        	    switch(pVal->file_directive_pdu.u.ack_pdu.directive_subtype_code) {
	        	        case DirectiveSubtypeCode_ack_others:
	        	            intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code = 0UL;
	        	            break;
	        	        case DirectiveSubtypeCode_ack_finished:
	        	            intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code = 1UL;
	        	            break;
	        	        default:                                    /*COVERAGE_IGNORE*/
	        	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	            *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	        	    }
	        	    if (ret) {
	        	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code, 4);
	        	    }
	        	    if (ret) {
	        	        /*Encode condition_code */
	        	        switch(pVal->file_directive_pdu.u.ack_pdu.condition_code) {
	        	            case ConditionCode_no_error:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 0UL;
	        	                break;
	        	            case ConditionCode_positive_ack_limit_reached:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 1UL;
	        	                break;
	        	            case ConditionCode_keep_alive_limit_reached:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 2UL;
	        	                break;
	        	            case ConditionCode_invalid_transmission_mode:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 3UL;
	        	                break;
	        	            case ConditionCode_filestore_rejection:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 4UL;
	        	                break;
	        	            case ConditionCode_file_checksum_failure:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 5UL;
	        	                break;
	        	            case ConditionCode_file_size_error:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 6UL;
	        	                break;
	        	            case ConditionCode_nak_limit_reached:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 7UL;
	        	                break;
	        	            case ConditionCode_inactivity_detected:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 8UL;
	        	                break;
	        	            case ConditionCode_invalid_file_structure:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 9UL;
	        	                break;
	        	            case ConditionCode_check_limit_reached:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 10UL;
	        	                break;
	        	            case ConditionCode_unsupported_checksum_type:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 11UL;
	        	                break;
	        	            case ConditionCode_suspend_request_received:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 12UL;
	        	                break;
	        	            case ConditionCode_cancel_request_received:
	        	                intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code = 13UL;
	        	                break;
	        	            default:                                    /*COVERAGE_IGNORE*/
	        	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	                *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	        	        }
	        	        if (ret) {
	        	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code, 4);
	        	        }
	        	        if (ret) {
	        	            /*Encode FileDirectiveType_file_directive_pdu_ack_pdu_spare */
	        	            {
	        	            	static byte tmp[] = {0x00};
	        	            	BitStream_AppendBits(pBitStrm, tmp, 2);
	        	            }
	        	            if (ret) {
	        	                /*Encode transaction_status */
	        	                switch(pVal->file_directive_pdu.u.ack_pdu.transaction_status) {
	        	                    case AckTransactionStatus_undefined:
	        	                        intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status = 0UL;
	        	                        break;
	        	                    case AckTransactionStatus_active:
	        	                        intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status = 1UL;
	        	                        break;
	        	                    case AckTransactionStatus_terminated:
	        	                        intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status = 2UL;
	        	                        break;
	        	                    case AckTransactionStatus_unrecognized:
	        	                        intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status = 3UL;
	        	                        break;
	        	                    default:                                    /*COVERAGE_IGNORE*/
	        	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	                        *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	        	                }
	        	                if (ret) {
	        	                	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status, 2);
	        	                }
	        	            }   /*COVERAGE_IGNORE*/
	        	        }   /*COVERAGE_IGNORE*/
	        	    }   /*COVERAGE_IGNORE*/
	        	}   /*COVERAGE_IGNORE*/
	        	break;
	        case FileDirectivePDU_metadata_pdu_PRESENT:
	        	/*Encode FileDirectiveType_file_directive_pdu_metadata_pdu_reserved1 */
	        	{
	        		static byte tmp[] = {0x00};
	        		BitStream_AppendBits(pBitStrm, tmp, 1);
	        	}
	        	if (ret) {
	        	    /*Encode closure_requested */
	        	    switch(pVal->file_directive_pdu.u.metadata_pdu.closure_requested) {
	        	        case ClosureRequested_requested:
	        	            intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested = 0UL;
	        	            break;
	        	        case ClosureRequested_not_requested:
	        	            intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested = 1UL;
	        	            break;
	        	        default:                                    /*COVERAGE_IGNORE*/
	        	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	            *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	        	    }
	        	    if (ret) {
	        	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested, 1);
	        	    }
	        	    if (ret) {
	        	        /*Encode FileDirectiveType_file_directive_pdu_metadata_pdu_reserved2 */
	        	        {
	        	        	static byte tmp[] = {0x00};
	        	        	BitStream_AppendBits(pBitStrm, tmp, 2);
	        	        }
	        	        if (ret) {
	        	            /*Encode checksum_type */
	        	            switch(pVal->file_directive_pdu.u.metadata_pdu.checksum_type) {
	        	                case ChecksumType_modular:
	        	                    intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type = 0UL;
	        	                    break;
	        	                case ChecksumType_none:
	        	                    intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type = 1UL;
	        	                    break;
	        	                default:                                    /*COVERAGE_IGNORE*/
	        	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	                    *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	        	            }
	        	            if (ret) {
	        	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type, 4);
	        	            }
	        	            if (ret) {
	        	                /*Encode file_size */
	        	                Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->file_directive_pdu.u.metadata_pdu.file_size);
	        	                if (ret) {
	        	                    if (pVal->file_directive_pdu.kind == FileDirectivePDU_metadata_pdu_PRESENT) {
	        	                        FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized = TRUE;
	        	                        FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size = pVal->file_directive_pdu.u.metadata_pdu.source_file_name.nCount;
	        	                    }
	        	                    if (ret) {
	        	                        /*Encode FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size */
	        	                        if (FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized) {
	        	                            ret = TRUE;
	        	                            Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size);
	        	                        } else {
	        	                            *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	        	                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        	                        }
	        	                    }   /*COVERAGE_IGNORE*/
	        	                    if (ret) {
	        	                        /*Encode source_file_name */
	        	                        ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->file_directive_pdu.u.metadata_pdu.source_file_name.arr, pVal->file_directive_pdu.u.metadata_pdu.source_file_name.nCount);
	        	                        if (ret) {
	        	                            if (pVal->file_directive_pdu.kind == FileDirectivePDU_metadata_pdu_PRESENT) {
	        	                                FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized = TRUE;
	        	                                FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size = pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.nCount;
	        	                            }
	        	                            if (ret) {
	        	                                /*Encode FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size */
	        	                                if (FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized) {
	        	                                    ret = TRUE;
	        	                                    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size);
	        	                                } else {
	        	                                    *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	        	                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	        	                                }
	        	                            }   /*COVERAGE_IGNORE*/
	        	                            if (ret) {
	        	                                /*Encode destination_file_name */
	        	                                ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.arr, pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.nCount);
	        	                            }   /*COVERAGE_IGNORE*/
	        	                        }   /*COVERAGE_IGNORE*/
	        	                    }   /*COVERAGE_IGNORE*/
	        	                }   /*COVERAGE_IGNORE*/
	        	            }   /*COVERAGE_IGNORE*/
	        	        }   /*COVERAGE_IGNORE*/
	        	    }   /*COVERAGE_IGNORE*/
	        	}   /*COVERAGE_IGNORE*/
	        	break;
	        default:
	            *pErrCode = ERR_ACN_ENCODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        }
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDirectiveType_ACN_Decode(cfdpFileDirectiveType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint FileDirectiveType_directive_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_finished_pdu_file_status;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code;
	asn1SccUint intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status;
	asn1SccUint FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size;
	asn1SccUint FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size;
	asn1SccUint intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested;
	asn1SccUint intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type;

	/*Decode FileDirectiveType_directive_code */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(FileDirectiveType_directive_code)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_DIRECTIVE_CODE;
	if (ret) {
	    /*Decode file_directive_pdu */
	    *pErrCode = 0;
	    if ((FileDirectiveType_directive_code == 4)) {
	        pVal->file_directive_pdu.kind = FileDirectivePDU_eof_pdu_PRESENT;
	        /*Decode condition_code */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code)), 4);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;
	        if (ret) {
	            switch (intVal_pVal_file_directive_pdu_u_eof_pdu_condition_code) {
	                case 0:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_no_error;
	                    break;
	                case 1:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                    break;
	                case 2:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                    break;
	                case 3:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                    break;
	                case 4:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_filestore_rejection;
	                    break;
	                case 5:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_file_checksum_failure;
	                    break;
	                case 6:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_file_size_error;
	                    break;
	                case 7:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_nak_limit_reached;
	                    break;
	                case 8:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_inactivity_detected;
	                    break;
	                case 9:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_invalid_file_structure;
	                    break;
	                case 10:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_check_limit_reached;
	                    break;
	                case 11:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                    break;
	                case 12:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_suspend_request_received;
	                    break;
	                case 13:
	                    pVal->file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_cancel_request_received;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode FileDirectiveType_file_directive_pdu_eof_pdu_spare */
	            {
	            	static byte tmp[] = {0x00};
	                flag bDecodingPatternMatches;
	            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 4, &bDecodingPatternMatches);
	                ret = ret && bDecodingPatternMatches;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_SPARE;
	            }

	            if (ret) {
	                /*Decode file_checksum */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_directive_pdu.u.eof_pdu.file_checksum)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_FILE_CHECKSUM;
	                if (ret) {
	                    /*Decode file_size */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_directive_pdu.u.eof_pdu.file_size)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_EOF_PDU_FILE_SIZE;
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }
	    else if ((FileDirectiveType_directive_code == 5)) {
	        pVal->file_directive_pdu.kind = FileDirectivePDU_finished_pdu_PRESENT;
	        /*Decode condition_code */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code)), 4);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;
	        if (ret) {
	            switch (intVal_pVal_file_directive_pdu_u_finished_pdu_condition_code) {
	                case 0:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_no_error;
	                    break;
	                case 1:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                    break;
	                case 2:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                    break;
	                case 3:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                    break;
	                case 4:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_filestore_rejection;
	                    break;
	                case 5:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_file_checksum_failure;
	                    break;
	                case 6:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_file_size_error;
	                    break;
	                case 7:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_nak_limit_reached;
	                    break;
	                case 8:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_inactivity_detected;
	                    break;
	                case 9:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_invalid_file_structure;
	                    break;
	                case 10:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_check_limit_reached;
	                    break;
	                case 11:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                    break;
	                case 12:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_suspend_request_received;
	                    break;
	                case 13:
	                    pVal->file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_cancel_request_received;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode FileDirectiveType_file_directive_pdu_finished_pdu_end_system_status */
	            {
	            	static byte tmp[] = {0x80};
	                flag bDecodingPatternMatches;
	            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                ret = ret && bDecodingPatternMatches;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_END_SYSTEM_STATUS;
	            }

	            if (ret) {
	                /*Decode delivery_code */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code)), 1);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;
	                if (ret) {
	                    switch (intVal_pVal_file_directive_pdu_u_finished_pdu_delivery_code) {
	                        case 0:
	                            pVal->file_directive_pdu.u.finished_pdu.delivery_code = DeliveryCode_data_complete;
	                            break;
	                        case 1:
	                            pVal->file_directive_pdu.u.finished_pdu.delivery_code = DeliveryCode_data_incomplete;
	                            break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	                    }
	                } /*COVERAGE_IGNORE*/
	                if (ret) {
	                    /*Decode file_status */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_finished_pdu_file_status)), 2);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;
	                    if (ret) {
	                        switch (intVal_pVal_file_directive_pdu_u_finished_pdu_file_status) {
	                            case 0:
	                                pVal->file_directive_pdu.u.finished_pdu.file_status = FileStatus_discarted_deliberately;
	                                break;
	                            case 1:
	                                pVal->file_directive_pdu.u.finished_pdu.file_status = FileStatus_discarted_file_rejection;
	                                break;
	                            case 2:
	                                pVal->file_directive_pdu.u.finished_pdu.file_status = FileStatus_retained_successfully;
	                                break;
	                            case 3:
	                                pVal->file_directive_pdu.u.finished_pdu.file_status = FileStatus_unreported;
	                                break;
	                        default:                                    /*COVERAGE_IGNORE*/
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	                        }
	                    } /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }
	    else if ((FileDirectiveType_directive_code == 6)) {
	        pVal->file_directive_pdu.kind = FileDirectivePDU_ack_pdu_PRESENT;
	        /*Decode directive_code_of_ack_pdu */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(pVal->file_directive_pdu.u.ack_pdu.directive_code_of_ack_pdu)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_CODE_OF_ACK_PDU;
	        if (ret) {
	            /*Decode directive_subtype_code */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code)), 4);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;
	            if (ret) {
	                switch (intVal_pVal_file_directive_pdu_u_ack_pdu_directive_subtype_code) {
	                    case 0:
	                        pVal->file_directive_pdu.u.ack_pdu.directive_subtype_code = DirectiveSubtypeCode_ack_others;
	                        break;
	                    case 1:
	                        pVal->file_directive_pdu.u.ack_pdu.directive_subtype_code = DirectiveSubtypeCode_ack_finished;
	                        break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	                }
	            } /*COVERAGE_IGNORE*/
	            if (ret) {
	                /*Decode condition_code */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code)), 4);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;
	                if (ret) {
	                    switch (intVal_pVal_file_directive_pdu_u_ack_pdu_condition_code) {
	                        case 0:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_no_error;
	                            break;
	                        case 1:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                            break;
	                        case 2:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                            break;
	                        case 3:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                            break;
	                        case 4:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_filestore_rejection;
	                            break;
	                        case 5:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_file_checksum_failure;
	                            break;
	                        case 6:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_file_size_error;
	                            break;
	                        case 7:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_nak_limit_reached;
	                            break;
	                        case 8:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_inactivity_detected;
	                            break;
	                        case 9:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_invalid_file_structure;
	                            break;
	                        case 10:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_check_limit_reached;
	                            break;
	                        case 11:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                            break;
	                        case 12:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_suspend_request_received;
	                            break;
	                        case 13:
	                            pVal->file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_cancel_request_received;
	                            break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                    }
	                } /*COVERAGE_IGNORE*/
	                if (ret) {
	                    /*Decode FileDirectiveType_file_directive_pdu_ack_pdu_spare */
	                    {
	                    	static byte tmp[] = {0x00};
	                        flag bDecodingPatternMatches;
	                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                        ret = ret && bDecodingPatternMatches;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_SPARE;
	                    }

	                    if (ret) {
	                        /*Decode transaction_status */
	                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status)), 2);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;
	                        if (ret) {
	                            switch (intVal_pVal_file_directive_pdu_u_ack_pdu_transaction_status) {
	                                case 0:
	                                    pVal->file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_undefined;
	                                    break;
	                                case 1:
	                                    pVal->file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_active;
	                                    break;
	                                case 2:
	                                    pVal->file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_terminated;
	                                    break;
	                                case 3:
	                                    pVal->file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_unrecognized;
	                                    break;
	                            default:                                    /*COVERAGE_IGNORE*/
	                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	                            }
	                        } /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }
	    else if ((FileDirectiveType_directive_code == 7)) {
	        pVal->file_directive_pdu.kind = FileDirectivePDU_metadata_pdu_PRESENT;
	        /*Decode FileDirectiveType_file_directive_pdu_metadata_pdu_reserved1 */
	        {
	        	static byte tmp[] = {0x00};
	            flag bDecodingPatternMatches;
	        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	            ret = ret && bDecodingPatternMatches;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_RESERVED1;
	        }

	        if (ret) {
	            /*Decode closure_requested */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested)), 1);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;
	            if (ret) {
	                switch (intVal_pVal_file_directive_pdu_u_metadata_pdu_closure_requested) {
	                    case 0:
	                        pVal->file_directive_pdu.u.metadata_pdu.closure_requested = ClosureRequested_requested;
	                        break;
	                    case 1:
	                        pVal->file_directive_pdu.u.metadata_pdu.closure_requested = ClosureRequested_not_requested;
	                        break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	                }
	            } /*COVERAGE_IGNORE*/
	            if (ret) {
	                /*Decode FileDirectiveType_file_directive_pdu_metadata_pdu_reserved2 */
	                {
	                	static byte tmp[] = {0x00};
	                    flag bDecodingPatternMatches;
	                	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                    ret = ret && bDecodingPatternMatches;
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_RESERVED2;
	                }

	                if (ret) {
	                    /*Decode checksum_type */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type)), 4);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;
	                    if (ret) {
	                        switch (intVal_pVal_file_directive_pdu_u_metadata_pdu_checksum_type) {
	                            case 0:
	                                pVal->file_directive_pdu.u.metadata_pdu.checksum_type = ChecksumType_modular;
	                                break;
	                            case 1:
	                                pVal->file_directive_pdu.u.metadata_pdu.checksum_type = ChecksumType_none;
	                                break;
	                        default:                                    /*COVERAGE_IGNORE*/
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	                        }
	                    } /*COVERAGE_IGNORE*/
	                    if (ret) {
	                        /*Decode file_size */
	                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->file_directive_pdu.u.metadata_pdu.file_size)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_FILE_SIZE;
	                        if (ret) {
	                            /*Decode FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME_SIZE;
	                            if (ret) {
	                                /*Decode source_file_name */
	                                ret = ((FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size<=128));
	                                if (ret) {
	                                    pVal->file_directive_pdu.u.metadata_pdu.source_file_name.nCount = (int)FileDirectiveType_file_directive_pdu_metadata_pdu_source_file_name_size;
	                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->file_directive_pdu.u.metadata_pdu.source_file_name.arr, pVal->file_directive_pdu.u.metadata_pdu.source_file_name.nCount);
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME;
	                                }
	                                if (ret) {
	                                    /*Decode FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size */
	                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size)));
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME_SIZE;
	                                    if (ret) {
	                                        /*Decode destination_file_name */
	                                        ret = ((FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size<=128));
	                                        if (ret) {
	                                            pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.nCount = (int)FileDirectiveType_file_directive_pdu_metadata_pdu_destination_file_name_size;
	                                            ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.arr, pVal->file_directive_pdu.u.metadata_pdu.destination_file_name.nCount);
	                                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME;
	                                        }
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }
	    else {
	        *pErrCode = ERR_ACN_DECODE_FILEDIRECTIVETYPE_FILE_DIRECTIVE_PDU;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpFileDirectiveType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpSegmentOffset_Equal(const cfdpSegmentOffset* pVal1, const cfdpSegmentOffset* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpSegmentOffset_IsConstraintValid(const cfdpSegmentOffset* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_SEGMENTOFFSET;

	return ret;
}

#ifdef __cplusplus
const cfdpSegmentOffset cfdpSegmentOffset_constant = 0UL;
#endif

void cfdpSegmentOffset_Initialize(cfdpSegmentOffset* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpSegmentOffset)cfdpSegmentOffset_constant;
}

flag cfdpSegmentOffset_Encode(const cfdpSegmentOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentOffset_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentOffset_Decode(cfdpSegmentOffset* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_SEGMENTOFFSET;

	return ret  && cfdpSegmentOffset_IsConstraintValid(pVal, pErrCode);
}

flag cfdpSegmentOffset_ACN_Encode(const cfdpSegmentOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentOffset_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentOffset_ACN_Decode(cfdpSegmentOffset* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SEGMENTOFFSET;

    return ret && cfdpSegmentOffset_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileData_Equal(const cfdpFileData* pVal1, const cfdpFileData* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpFileData_IsConstraintValid(const cfdpFileData* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 4096);
    *pErrCode = ret ? 0 :  ERR_FILEDATA;

	return ret;
}

#ifdef __cplusplus
const cfdpFileData cfdpFileData_constant = {.nCount = 0, .arr  = {[0 ... 4096-1] = 0 }};
#endif

void cfdpFileData_Initialize(cfdpFileData* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileData)cfdpFileData_constant;
}

flag cfdpFileData_Encode(const cfdpFileData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 4096);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileData_Decode(cfdpFileData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 4096);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILEDATA;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpFileData_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileData_ACN_Encode(const cfdpFileData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 4096);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileData_ACN_Decode(cfdpFileData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 4096);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDATA;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpFileData_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileDataPDU_Equal(const cfdpFileDataPDU* pVal1, const cfdpFileDataPDU* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->segment_offset == pVal2->segment_offset);

    if (ret) {
        ret = cfdpFileData_Equal((&(pVal1->file_data)), (&(pVal2->file_data)));

    }

	return ret;

}

flag cfdpFileDataPDU_IsConstraintValid(const cfdpFileDataPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpSegmentOffset_IsConstraintValid((&(pVal->segment_offset)), pErrCode);
    if (ret) {
        ret = cfdpFileData_IsConstraintValid((&(pVal->file_data)), pErrCode);
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpFileDataPDU cfdpFileDataPDU_constant = {.segment_offset = 0UL, .file_data = {.nCount = 0, .arr  = {[0 ... 4096-1] = 0 }}};
#endif

void cfdpFileDataPDU_Initialize(cfdpFileDataPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileDataPDU)cfdpFileDataPDU_constant;
}

flag cfdpFileDataPDU_Encode(const cfdpFileDataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode segment_offset */
	    ret = cfdpSegmentOffset_Encode((&(pVal->segment_offset)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode file_data */
	        ret = cfdpFileData_Encode((&(pVal->file_data)), pBitStrm, pErrCode, FALSE);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDataPDU_Decode(cfdpFileDataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode segment_offset */
	ret = cfdpSegmentOffset_Decode((&(pVal->segment_offset)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode file_data */
	    ret = cfdpFileData_Decode((&(pVal->file_data)), pBitStrm, pErrCode);
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpFileDataPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileDataPDU_ACN_Encode(const cfdpFileDataPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint FileDataPDU_file_data_length;
	flag FileDataPDU_file_data_length_is_initialized=FALSE;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDataPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode segment_offset */
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->segment_offset);
	    if (ret) {
	        FileDataPDU_file_data_length_is_initialized = TRUE;
	        FileDataPDU_file_data_length = pVal->file_data.nCount;
	        if (ret) {
	            /*Encode FileDataPDU_file_data_length */
	            if (FileDataPDU_file_data_length_is_initialized) {
	                ret = TRUE;
	                Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, FileDataPDU_file_data_length);
	            } else {
	                *pErrCode = ERR_ACN_ENCODE_FILEDATAPDU_FILE_DATA_LENGTH_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                ret = FALSE;                    /*COVERAGE_IGNORE*/
	            }
	        }   /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Encode file_data */
	            ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->file_data.arr, pVal->file_data.nCount);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDataPDU_ACN_Decode(cfdpFileDataPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint FileDataPDU_file_data_length;

	/*Decode segment_offset */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->segment_offset)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDATAPDU_SEGMENT_OFFSET;
	if (ret) {
	    /*Decode FileDataPDU_file_data_length */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, (&(FileDataPDU_file_data_length)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDATAPDU_FILE_DATA_LENGTH;
	    if (ret) {
	        /*Decode file_data */
	        ret = ((FileDataPDU_file_data_length<=4096));
	        if (ret) {
	            pVal->file_data.nCount = (int)FileDataPDU_file_data_length;
	            ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->file_data.arr, pVal->file_data.nCount);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILEDATAPDU_FILE_DATA;
	        }
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpFileDataPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpFileDataType_Equal(const cfdpFileDataType* pVal1, const cfdpFileDataType* pVal2)
{
	flag ret=TRUE;

    ret = cfdpFileDataPDU_Equal((&(pVal1->file_data_pdu)), (&(pVal2->file_data_pdu)));

	return ret;

}

flag cfdpFileDataType_IsConstraintValid(const cfdpFileDataType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpFileDataPDU_IsConstraintValid((&(pVal->file_data_pdu)), pErrCode);

	return ret;
}

#ifdef __cplusplus
const cfdpFileDataType cfdpFileDataType_constant = {.file_data_pdu = cfdpFileDataPDU_constant};
#endif

void cfdpFileDataType_Initialize(cfdpFileDataType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpFileDataType)cfdpFileDataType_constant;
}

flag cfdpFileDataType_Encode(const cfdpFileDataType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDataType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode file_data_pdu */
	    ret = cfdpFileDataPDU_Encode((&(pVal->file_data_pdu)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDataType_Decode(cfdpFileDataType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode file_data_pdu */
	ret = cfdpFileDataPDU_Decode((&(pVal->file_data_pdu)), pBitStrm, pErrCode);

	return ret  && cfdpFileDataType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpFileDataType_ACN_Encode(const cfdpFileDataType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpFileDataType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode file_data_pdu */
	    ret = cfdpFileDataPDU_ACN_Encode((&(pVal->file_data_pdu)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpFileDataType_ACN_Decode(cfdpFileDataType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode file_data_pdu */
	ret = cfdpFileDataPDU_ACN_Decode((&(pVal->file_data_pdu)), pBitStrm, pErrCode);

    return ret && cfdpFileDataType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPayloadData_Equal(const cfdpPayloadData* pVal1, const cfdpPayloadData* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind)
    	{
    	case PayloadData_file_directive_PRESENT:
    		ret = cfdpFileDirectiveType_Equal((&(pVal1->u.file_directive)), (&(pVal2->u.file_directive)));
    		break;
    	case PayloadData_file_data_PRESENT:
    		ret = cfdpFileDataType_Equal((&(pVal1->u.file_data)), (&(pVal2->u.file_data)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag cfdpPayloadData_IsConstraintValid(const cfdpPayloadData* pVal, int* pErrCode)
{
    flag ret = TRUE;
    switch (pVal->kind) {
        case PayloadData_file_directive_PRESENT : 
            ret = cfdpFileDirectiveType_IsConstraintValid((&(pVal->u.file_directive)), pErrCode);
            break;          
        case PayloadData_file_data_PRESENT : 
            ret = cfdpFileDataType_IsConstraintValid((&(pVal->u.file_data)), pErrCode);
            break;          
        default: /*COVERAGE_IGNORE*/
    	    *pErrCode = ERR_PAYLOADDATA;      /*COVERAGE_IGNORE*/
    	    ret = FALSE;                               /*COVERAGE_IGNORE*/
    }

	return ret;
}

#ifdef __cplusplus
const cfdpPayloadData cfdpPayloadData_constant = {.kind = PayloadData_file_directive_PRESENT, .u.file_directive = cfdpFileDirectiveType_constant};
#endif

void cfdpPayloadData_Initialize(cfdpPayloadData* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPayloadData)cfdpPayloadData_constant;
}

flag cfdpPayloadData_Encode(const cfdpPayloadData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPayloadData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind)
	    {
	    case PayloadData_file_directive_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = cfdpFileDirectiveType_Encode((&(pVal->u.file_directive)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case PayloadData_file_data_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = cfdpFileDataType_Encode((&(pVal->u.file_data)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_PAYLOADDATA;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPayloadData_Decode(cfdpPayloadData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint cfdpPayloadData_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &cfdpPayloadData_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PAYLOADDATA;
	if (ret) {
	    switch(cfdpPayloadData_index_tmp)
	    {
	    case 0:
	    	pVal->kind = PayloadData_file_directive_PRESENT;
	    	ret = cfdpFileDirectiveType_Decode((&(pVal->u.file_directive)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PayloadData_file_data_PRESENT;
	    	ret = cfdpFileDataType_Decode((&(pVal->u.file_data)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_PAYLOADDATA;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && cfdpPayloadData_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPayloadData_ACN_Encode(const cfdpPayloadData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPayloadData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind)
	    {
	    case PayloadData_file_directive_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = cfdpFileDirectiveType_ACN_Encode((&(pVal->u.file_directive)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case PayloadData_file_data_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = cfdpFileDataType_ACN_Encode((&(pVal->u.file_data)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_PAYLOADDATA;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPayloadData_ACN_Decode(cfdpPayloadData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint CFDP_PROTOCOL_PayloadData_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &CFDP_PROTOCOL_PayloadData_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PAYLOADDATA;
	if (ret) {
	    switch(CFDP_PROTOCOL_PayloadData_index_tmp)
	    {
	    case 0:
	    	pVal->kind = PayloadData_file_directive_PRESENT;
	    	ret = cfdpFileDirectiveType_ACN_Decode((&(pVal->u.file_directive)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PayloadData_file_data_PRESENT;
	    	ret = cfdpFileDataType_ACN_Decode((&(pVal->u.file_data)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PAYLOADDATA;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpPayloadData_IsConstraintValid(pVal, pErrCode);
}


flag cfdpResponseRequired_Equal(const cfdpResponseRequired* pVal1, const cfdpResponseRequired* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpResponseRequired_IsConstraintValid(const cfdpResponseRequired* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == ResponseRequired_nak)) || (((*(pVal)) == ResponseRequired_keep_alive)));
    *pErrCode = ret ? 0 :  ERR_RESPONSEREQUIRED;

	return ret;
}

#ifdef __cplusplus
const cfdpResponseRequired cfdpResponseRequired_constant = ResponseRequired_nak;
#endif

void cfdpResponseRequired_Initialize(cfdpResponseRequired* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpResponseRequired)cfdpResponseRequired_constant;
}

flag cfdpResponseRequired_Encode(const cfdpResponseRequired* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpResponseRequired_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case ResponseRequired_nak:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case ResponseRequired_keep_alive:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_RESPONSEREQUIRED; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpResponseRequired_Decode(cfdpResponseRequired* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_RESPONSEREQUIRED;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = ResponseRequired_nak;
	                break;
	            case 1:
	                (*(pVal)) = ResponseRequired_keep_alive;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_RESPONSEREQUIRED;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = ResponseRequired_nak;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpResponseRequired_IsConstraintValid(pVal, pErrCode);
}

flag cfdpResponseRequired_ACN_Encode(const cfdpResponseRequired* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpResponseRequired_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case ResponseRequired_nak:
	            intVal_pVal = 0UL;
	            break;
	        case ResponseRequired_keep_alive:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_RESPONSEREQUIRED;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpResponseRequired_ACN_Decode(cfdpResponseRequired* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_RESPONSEREQUIRED;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = ResponseRequired_nak;
	            break;
	        case 1:
	            (*(pVal)) = ResponseRequired_keep_alive;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_RESPONSEREQUIRED;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpResponseRequired_IsConstraintValid(pVal, pErrCode);
}


flag cfdpProgress_Equal(const cfdpProgress* pVal1, const cfdpProgress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpProgress_IsConstraintValid(const cfdpProgress* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_PROGRESS;

	return ret;
}

#ifdef __cplusplus
const cfdpProgress cfdpProgress_constant = 0UL;
#endif

void cfdpProgress_Initialize(cfdpProgress* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpProgress)cfdpProgress_constant;
}

flag cfdpProgress_Encode(const cfdpProgress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpProgress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProgress_Decode(cfdpProgress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PROGRESS;

	return ret  && cfdpProgress_IsConstraintValid(pVal, pErrCode);
}

flag cfdpProgress_ACN_Encode(const cfdpProgress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpProgress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpProgress_ACN_Decode(cfdpProgress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PROGRESS;

    return ret && cfdpProgress_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionStatus_Equal(const cfdpTransactionStatus* pVal1, const cfdpTransactionStatus* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransactionStatus_IsConstraintValid(const cfdpTransactionStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == TransactionStatus_discarted_deliberately)) || (((*(pVal)) == TransactionStatus_discarted_file_rejection)))) || (((*(pVal)) == TransactionStatus_retained_successfully)))) || (((*(pVal)) == TransactionStatus_unreported)));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSTATUS;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionStatus cfdpTransactionStatus_constant = TransactionStatus_discarted_deliberately;
#endif

void cfdpTransactionStatus_Initialize(cfdpTransactionStatus* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionStatus)cfdpTransactionStatus_constant;
}

flag cfdpTransactionStatus_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransactionStatus_discarted_deliberately:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case TransactionStatus_discarted_file_rejection:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case TransactionStatus_retained_successfully:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case TransactionStatus_unreported:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSACTIONSTATUS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSTATUS;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransactionStatus_discarted_deliberately;
	                break;
	            case 1:
	                (*(pVal)) = TransactionStatus_discarted_file_rejection;
	                break;
	            case 2:
	                (*(pVal)) = TransactionStatus_retained_successfully;
	                break;
	            case 3:
	                (*(pVal)) = TransactionStatus_unreported;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSACTIONSTATUS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransactionStatus_discarted_deliberately;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionStatus_ACN_Encode(const cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransactionStatus_discarted_deliberately:
	            intVal_pVal = 0UL;
	            break;
	        case TransactionStatus_discarted_file_rejection:
	            intVal_pVal = 1UL;
	            break;
	        case TransactionStatus_retained_successfully:
	            intVal_pVal = 2UL;
	            break;
	        case TransactionStatus_unreported:
	            intVal_pVal = 3UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionStatus_ACN_Decode(cfdpTransactionStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSTATUS;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransactionStatus_discarted_deliberately;
	            break;
	        case 1:
	            (*(pVal)) = TransactionStatus_discarted_file_rejection;
	            break;
	        case 2:
	            (*(pVal)) = TransactionStatus_retained_successfully;
	            break;
	        case 3:
	            (*(pVal)) = TransactionStatus_unreported;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSACTIONSTATUS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransactionStatus_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTypeFieldCode_Equal(const cfdpTypeFieldCode* pVal1, const cfdpTypeFieldCode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTypeFieldCode_IsConstraintValid(const cfdpTypeFieldCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == TypeFieldCode_filestore_request)) || (((*(pVal)) == TypeFieldCode_filestore_response)))) || (((*(pVal)) == TypeFieldCode_message_to_user)))) || (((*(pVal)) == TypeFieldCode_fault_handler_overrides)))) || (((*(pVal)) == TypeFieldCode_flow_label)))) || (((*(pVal)) == TypeFieldCode_entity_id)));
    *pErrCode = ret ? 0 :  ERR_TYPEFIELDCODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTypeFieldCode cfdpTypeFieldCode_constant = TypeFieldCode_filestore_request;
#endif

void cfdpTypeFieldCode_Initialize(cfdpTypeFieldCode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTypeFieldCode)cfdpTypeFieldCode_constant;
}

flag cfdpTypeFieldCode_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TypeFieldCode_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case TypeFieldCode_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case TypeFieldCode_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case TypeFieldCode_fault_handler_overrides:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case TypeFieldCode_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case TypeFieldCode_entity_id:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TYPEFIELDCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TYPEFIELDCODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TypeFieldCode_filestore_request;
	                break;
	            case 1:
	                (*(pVal)) = TypeFieldCode_filestore_response;
	                break;
	            case 2:
	                (*(pVal)) = TypeFieldCode_message_to_user;
	                break;
	            case 3:
	                (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	                break;
	            case 4:
	                (*(pVal)) = TypeFieldCode_flow_label;
	                break;
	            case 5:
	                (*(pVal)) = TypeFieldCode_entity_id;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TYPEFIELDCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TypeFieldCode_filestore_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTypeFieldCode_ACN_Encode(const cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TypeFieldCode_filestore_request:
	            intVal_pVal = 0UL;
	            break;
	        case TypeFieldCode_filestore_response:
	            intVal_pVal = 1UL;
	            break;
	        case TypeFieldCode_message_to_user:
	            intVal_pVal = 2UL;
	            break;
	        case TypeFieldCode_fault_handler_overrides:
	            intVal_pVal = 3UL;
	            break;
	        case TypeFieldCode_flow_label:
	            intVal_pVal = 4UL;
	            break;
	        case TypeFieldCode_entity_id:
	            intVal_pVal = 5UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTypeFieldCode_ACN_Decode(cfdpTypeFieldCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TYPEFIELDCODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TypeFieldCode_filestore_request;
	            break;
	        case 1:
	            (*(pVal)) = TypeFieldCode_filestore_response;
	            break;
	        case 2:
	            (*(pVal)) = TypeFieldCode_message_to_user;
	            break;
	        case 3:
	            (*(pVal)) = TypeFieldCode_fault_handler_overrides;
	            break;
	        case 4:
	            (*(pVal)) = TypeFieldCode_flow_label;
	            break;
	        case 5:
	            (*(pVal)) = TypeFieldCode_entity_id;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TYPEFIELDCODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTypeFieldCode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpMessageType_Equal(const cfdpMessageType* pVal1, const cfdpMessageType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpMessageType_IsConstraintValid(const cfdpMessageType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((((((*(pVal)) == MessageType_proxy_put_request)) || (((*(pVal)) == MessageType_proxy_message_to_user)))) || (((*(pVal)) == MessageType_proxy_filestore_request)))) || (((*(pVal)) == MessageType_proxy_fault_handler_override)))) || (((*(pVal)) == MessageType_proxy_transmission_mode)))) || (((*(pVal)) == MessageType_proxy_flow_label)))) || (((*(pVal)) == MessageType_proxy_segmentation_control)))) || (((*(pVal)) == MessageType_proxy_put_response)))) || (((*(pVal)) == MessageType_proxy_filestore_response)))) || (((*(pVal)) == MessageType_proxy_put_cancel)))) || (((*(pVal)) == MessageType_directory_listing_request)))) || (((*(pVal)) == MessageType_directory_listing_response)))) || (((*(pVal)) == MessageType_remote_status_report_request)))) || (((*(pVal)) == MessageType_remote_status_report_response)))) || (((*(pVal)) == MessageType_remote_suspend_request)))) || (((*(pVal)) == MessageType_remote_suspend_response)))) || (((*(pVal)) == MessageType_remote_resume_request)))) || (((*(pVal)) == MessageType_remote_resume_response)));
    *pErrCode = ret ? 0 :  ERR_MESSAGETYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpMessageType cfdpMessageType_constant = MessageType_proxy_put_request;
#endif

void cfdpMessageType_Initialize(cfdpMessageType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpMessageType)cfdpMessageType_constant;
}

flag cfdpMessageType_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case MessageType_proxy_put_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 17);
	        	break;
	        case MessageType_proxy_message_to_user:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 17);
	        	break;
	        case MessageType_proxy_fault_handler_override:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 17);
	        	break;
	        case MessageType_proxy_transmission_mode:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 17);
	        	break;
	        case MessageType_proxy_flow_label:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 17);
	        	break;
	        case MessageType_proxy_segmentation_control:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 17);
	        	break;
	        case MessageType_proxy_put_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 17);
	        	break;
	        case MessageType_proxy_filestore_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 17);
	        	break;
	        case MessageType_proxy_put_cancel:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 17);
	        	break;
	        case MessageType_directory_listing_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 17);
	        	break;
	        case MessageType_directory_listing_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 17);
	        	break;
	        case MessageType_remote_status_report_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 17);
	        	break;
	        case MessageType_remote_status_report_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 17);
	        	break;
	        case MessageType_remote_suspend_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 17);
	        	break;
	        case MessageType_remote_suspend_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 17);
	        	break;
	        case MessageType_remote_resume_request:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 16, 0, 17);
	        	break;
	        case MessageType_remote_resume_response:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 17, 0, 17);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_MESSAGETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 17);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_MESSAGETYPE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = MessageType_proxy_put_request;
	                break;
	            case 1:
	                (*(pVal)) = MessageType_proxy_message_to_user;
	                break;
	            case 2:
	                (*(pVal)) = MessageType_proxy_filestore_request;
	                break;
	            case 3:
	                (*(pVal)) = MessageType_proxy_fault_handler_override;
	                break;
	            case 4:
	                (*(pVal)) = MessageType_proxy_transmission_mode;
	                break;
	            case 5:
	                (*(pVal)) = MessageType_proxy_flow_label;
	                break;
	            case 6:
	                (*(pVal)) = MessageType_proxy_segmentation_control;
	                break;
	            case 7:
	                (*(pVal)) = MessageType_proxy_put_response;
	                break;
	            case 8:
	                (*(pVal)) = MessageType_proxy_filestore_response;
	                break;
	            case 9:
	                (*(pVal)) = MessageType_proxy_put_cancel;
	                break;
	            case 10:
	                (*(pVal)) = MessageType_directory_listing_request;
	                break;
	            case 11:
	                (*(pVal)) = MessageType_directory_listing_response;
	                break;
	            case 12:
	                (*(pVal)) = MessageType_remote_status_report_request;
	                break;
	            case 13:
	                (*(pVal)) = MessageType_remote_status_report_response;
	                break;
	            case 14:
	                (*(pVal)) = MessageType_remote_suspend_request;
	                break;
	            case 15:
	                (*(pVal)) = MessageType_remote_suspend_response;
	                break;
	            case 16:
	                (*(pVal)) = MessageType_remote_resume_request;
	                break;
	            case 17:
	                (*(pVal)) = MessageType_remote_resume_response;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_MESSAGETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = MessageType_proxy_put_request;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpMessageType_ACN_Encode(const cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpMessageType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case MessageType_proxy_put_request:
	            intVal_pVal = 0UL;
	            break;
	        case MessageType_proxy_message_to_user:
	            intVal_pVal = 1UL;
	            break;
	        case MessageType_proxy_filestore_request:
	            intVal_pVal = 2UL;
	            break;
	        case MessageType_proxy_fault_handler_override:
	            intVal_pVal = 3UL;
	            break;
	        case MessageType_proxy_transmission_mode:
	            intVal_pVal = 4UL;
	            break;
	        case MessageType_proxy_flow_label:
	            intVal_pVal = 5UL;
	            break;
	        case MessageType_proxy_segmentation_control:
	            intVal_pVal = 6UL;
	            break;
	        case MessageType_proxy_put_response:
	            intVal_pVal = 7UL;
	            break;
	        case MessageType_proxy_filestore_response:
	            intVal_pVal = 8UL;
	            break;
	        case MessageType_proxy_put_cancel:
	            intVal_pVal = 9UL;
	            break;
	        case MessageType_directory_listing_request:
	            intVal_pVal = 10UL;
	            break;
	        case MessageType_directory_listing_response:
	            intVal_pVal = 11UL;
	            break;
	        case MessageType_remote_status_report_request:
	            intVal_pVal = 12UL;
	            break;
	        case MessageType_remote_status_report_response:
	            intVal_pVal = 13UL;
	            break;
	        case MessageType_remote_suspend_request:
	            intVal_pVal = 14UL;
	            break;
	        case MessageType_remote_suspend_response:
	            intVal_pVal = 15UL;
	            break;
	        case MessageType_remote_resume_request:
	            intVal_pVal = 16UL;
	            break;
	        case MessageType_remote_resume_response:
	            intVal_pVal = 17UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, intVal_pVal);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpMessageType_ACN_Decode(cfdpMessageType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(intVal_pVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MESSAGETYPE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = MessageType_proxy_put_request;
	            break;
	        case 1:
	            (*(pVal)) = MessageType_proxy_message_to_user;
	            break;
	        case 2:
	            (*(pVal)) = MessageType_proxy_filestore_request;
	            break;
	        case 3:
	            (*(pVal)) = MessageType_proxy_fault_handler_override;
	            break;
	        case 4:
	            (*(pVal)) = MessageType_proxy_transmission_mode;
	            break;
	        case 5:
	            (*(pVal)) = MessageType_proxy_flow_label;
	            break;
	        case 6:
	            (*(pVal)) = MessageType_proxy_segmentation_control;
	            break;
	        case 7:
	            (*(pVal)) = MessageType_proxy_put_response;
	            break;
	        case 8:
	            (*(pVal)) = MessageType_proxy_filestore_response;
	            break;
	        case 9:
	            (*(pVal)) = MessageType_proxy_put_cancel;
	            break;
	        case 10:
	            (*(pVal)) = MessageType_directory_listing_request;
	            break;
	        case 11:
	            (*(pVal)) = MessageType_directory_listing_response;
	            break;
	        case 12:
	            (*(pVal)) = MessageType_remote_status_report_request;
	            break;
	        case 13:
	            (*(pVal)) = MessageType_remote_status_report_response;
	            break;
	        case 14:
	            (*(pVal)) = MessageType_remote_suspend_request;
	            break;
	        case 15:
	            (*(pVal)) = MessageType_remote_suspend_response;
	            break;
	        case 16:
	            (*(pVal)) = MessageType_remote_resume_request;
	            break;
	        case 17:
	            (*(pVal)) = MessageType_remote_resume_response;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_MESSAGETYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpMessageType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUType_Equal(const cfdpPDUType* pVal1, const cfdpPDUType* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUType_IsConstraintValid(const cfdpPDUType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1UL);
    *pErrCode = ret ? 0 :  ERR_PDUTYPE;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUType cfdpPDUType_constant = 0UL;
#endif

void cfdpPDUType_Initialize(cfdpPDUType* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUType)cfdpPDUType_constant;
}

flag cfdpPDUType_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUTYPE;

	return ret  && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUType_ACN_Encode(const cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUType_ACN_Decode(cfdpPDUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUTYPE;

    return ret && cfdpPDUType_IsConstraintValid(pVal, pErrCode);
}


flag cfdpVersion_Equal(const cfdpVersion* pVal1, const cfdpVersion* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpVersion_IsConstraintValid(const cfdpVersion* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_VERSION;

	return ret;
}

#ifdef __cplusplus
const cfdpVersion cfdpVersion_constant = 0UL;
#endif

void cfdpVersion_Initialize(cfdpVersion* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpVersion)cfdpVersion_constant;
}

flag cfdpVersion_Encode(const cfdpVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpVersion_Decode(cfdpVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VERSION;

	return ret  && cfdpVersion_IsConstraintValid(pVal, pErrCode);
}

flag cfdpVersion_ACN_Encode(const cfdpVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpVersion_ACN_Decode(cfdpVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_VERSION;

    return ret && cfdpVersion_IsConstraintValid(pVal, pErrCode);
}


flag cfdpDirection_Equal(const cfdpDirection* pVal1, const cfdpDirection* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpDirection_IsConstraintValid(const cfdpDirection* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == Direction_toward_receiver)) || (((*(pVal)) == Direction_toward_sender)));
    *pErrCode = ret ? 0 :  ERR_DIRECTION;

	return ret;
}

#ifdef __cplusplus
const cfdpDirection cfdpDirection_constant = Direction_toward_receiver;
#endif

void cfdpDirection_Initialize(cfdpDirection* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpDirection)cfdpDirection_constant;
}

flag cfdpDirection_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case Direction_toward_receiver:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case Direction_toward_sender:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DIRECTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DIRECTION;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = Direction_toward_receiver;
	                break;
	            case 1:
	                (*(pVal)) = Direction_toward_sender;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DIRECTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = Direction_toward_receiver;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}

flag cfdpDirection_ACN_Encode(const cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpDirection_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case Direction_toward_receiver:
	            intVal_pVal = 0UL;
	            break;
	        case Direction_toward_sender:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpDirection_ACN_Decode(cfdpDirection* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DIRECTION;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = Direction_toward_receiver;
	            break;
	        case 1:
	            (*(pVal)) = Direction_toward_sender;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpDirection_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransmissionMode_Equal(const cfdpTransmissionMode* pVal1, const cfdpTransmissionMode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpTransmissionMode_IsConstraintValid(const cfdpTransmissionMode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == TransmissionMode_acknowledged)) || (((*(pVal)) == TransmissionMode_unacknowledged)));
    *pErrCode = ret ? 0 :  ERR_TRANSMISSIONMODE;

	return ret;
}

#ifdef __cplusplus
const cfdpTransmissionMode cfdpTransmissionMode_constant = TransmissionMode_acknowledged;
#endif

void cfdpTransmissionMode_Initialize(cfdpTransmissionMode* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransmissionMode)cfdpTransmissionMode_constant;
}

flag cfdpTransmissionMode_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case TransmissionMode_acknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case TransmissionMode_unacknowledged:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TRANSMISSIONMODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSMISSIONMODE;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = TransmissionMode_acknowledged;
	                break;
	            case 1:
	                (*(pVal)) = TransmissionMode_unacknowledged;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TRANSMISSIONMODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = TransmissionMode_acknowledged;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransmissionMode_ACN_Encode(const cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case TransmissionMode_acknowledged:
	            intVal_pVal = 0UL;
	            break;
	        case TransmissionMode_unacknowledged:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransmissionMode_ACN_Decode(cfdpTransmissionMode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSMISSIONMODE;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = TransmissionMode_acknowledged;
	            break;
	        case 1:
	            (*(pVal)) = TransmissionMode_unacknowledged;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TRANSMISSIONMODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpTransmissionMode_IsConstraintValid(pVal, pErrCode);
}


flag cfdpCRCFlag_Equal(const cfdpCRCFlag* pVal1, const cfdpCRCFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpCRCFlag_IsConstraintValid(const cfdpCRCFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == CRCFlag_crc_not_present)) || (((*(pVal)) == CRCFlag_crc_present)));
    *pErrCode = ret ? 0 :  ERR_CRCFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpCRCFlag cfdpCRCFlag_constant = CRCFlag_crc_not_present;
#endif

void cfdpCRCFlag_Initialize(cfdpCRCFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpCRCFlag)cfdpCRCFlag_constant;
}

flag cfdpCRCFlag_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case CRCFlag_crc_not_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case CRCFlag_crc_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CRCFLAG; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CRCFLAG;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = CRCFlag_crc_not_present;
	                break;
	            case 1:
	                (*(pVal)) = CRCFlag_crc_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CRCFLAG;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = CRCFlag_crc_not_present;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpCRCFlag_ACN_Encode(const cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpCRCFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case CRCFlag_crc_not_present:
	            intVal_pVal = 0UL;
	            break;
	        case CRCFlag_crc_present:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCRCFlag_ACN_Decode(cfdpCRCFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CRCFLAG;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = CRCFlag_crc_not_present;
	            break;
	        case 1:
	            (*(pVal)) = CRCFlag_crc_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CRCFLAG;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpCRCFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLargeFileFlag_Equal(const cfdpLargeFileFlag* pVal1, const cfdpLargeFileFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLargeFileFlag_IsConstraintValid(const cfdpLargeFileFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1UL);
    *pErrCode = ret ? 0 :  ERR_LARGEFILEFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpLargeFileFlag cfdpLargeFileFlag_constant = 0UL;
#endif

void cfdpLargeFileFlag_Initialize(cfdpLargeFileFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLargeFileFlag)cfdpLargeFileFlag_constant;
}

flag cfdpLargeFileFlag_Encode(const cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLargeFileFlag_Decode(cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LARGEFILEFLAG;

	return ret  && cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLargeFileFlag_ACN_Encode(const cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 1);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLargeFileFlag_ACN_Decode(cfdpLargeFileFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LARGEFILEFLAG;

    return ret && cfdpLargeFileFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUDataFieldLength_Equal(const cfdpPDUDataFieldLength* pVal1, const cfdpPDUDataFieldLength* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpPDUDataFieldLength_IsConstraintValid(const cfdpPDUDataFieldLength* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_PDUDATAFIELDLENGTH;

	return ret;
}

#ifdef __cplusplus
const cfdpPDUDataFieldLength cfdpPDUDataFieldLength_constant = 0UL;
#endif

void cfdpPDUDataFieldLength_Initialize(cfdpPDUDataFieldLength* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUDataFieldLength)cfdpPDUDataFieldLength_constant;
}

flag cfdpPDUDataFieldLength_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PDUDATAFIELDLENGTH;

	return ret  && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUDataFieldLength_ACN_Encode(const cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUDataFieldLength_ACN_Decode(cfdpPDUDataFieldLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PDUDATAFIELDLENGTH;

    return ret && cfdpPDUDataFieldLength_IsConstraintValid(pVal, pErrCode);
}


flag cfdpSegmentationControl_Equal(const cfdpSegmentationControl* pVal1, const cfdpSegmentationControl* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpSegmentationControl_IsConstraintValid(const cfdpSegmentationControl* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == SegmentationControl_record_boundries_not_preserved)) || (((*(pVal)) == SegmentationControl_record_boundries_preserved)));
    *pErrCode = ret ? 0 :  ERR_SEGMENTATIONCONTROL;

	return ret;
}

#ifdef __cplusplus
const cfdpSegmentationControl cfdpSegmentationControl_constant = SegmentationControl_record_boundries_not_preserved;
#endif

void cfdpSegmentationControl_Initialize(cfdpSegmentationControl* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpSegmentationControl)cfdpSegmentationControl_constant;
}

flag cfdpSegmentationControl_Encode(const cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case SegmentationControl_record_boundries_not_preserved:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case SegmentationControl_record_boundries_preserved:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SEGMENTATIONCONTROL; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentationControl_Decode(cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SEGMENTATIONCONTROL;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = SegmentationControl_record_boundries_not_preserved;
	                break;
	            case 1:
	                (*(pVal)) = SegmentationControl_record_boundries_preserved;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SEGMENTATIONCONTROL;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = SegmentationControl_record_boundries_not_preserved;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode);
}

flag cfdpSegmentationControl_ACN_Encode(const cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case SegmentationControl_record_boundries_not_preserved:
	            intVal_pVal = 0UL;
	            break;
	        case SegmentationControl_record_boundries_preserved:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SEGMENTATIONCONTROL;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentationControl_ACN_Decode(cfdpSegmentationControl* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SEGMENTATIONCONTROL;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = SegmentationControl_record_boundries_not_preserved;
	            break;
	        case 1:
	            (*(pVal)) = SegmentationControl_record_boundries_preserved;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SEGMENTATIONCONTROL;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpSegmentationControl_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfEntityIds_Equal(const cfdpLengthOfEntityIds* pVal1, const cfdpLengthOfEntityIds* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfEntityIds_IsConstraintValid(const cfdpLengthOfEntityIds* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFENTITYIDS;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfEntityIds cfdpLengthOfEntityIds_constant = 0UL;
#endif

void cfdpLengthOfEntityIds_Initialize(cfdpLengthOfEntityIds* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfEntityIds)cfdpLengthOfEntityIds_constant;
}

flag cfdpLengthOfEntityIds_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFENTITYIDS;

	return ret  && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfEntityIds_ACN_Encode(const cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfEntityIds_ACN_Decode(cfdpLengthOfEntityIds* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFENTITYIDS;

    return ret && cfdpLengthOfEntityIds_IsConstraintValid(pVal, pErrCode);
}


flag cfdpSegmentMetadataFlag_Equal(const cfdpSegmentMetadataFlag* pVal1, const cfdpSegmentMetadataFlag* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpSegmentMetadataFlag_IsConstraintValid(const cfdpSegmentMetadataFlag* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == SegmentMetadataFlag_flag_present)) || (((*(pVal)) == SegmentMetadataFlag_flag_not_present)));
    *pErrCode = ret ? 0 :  ERR_SEGMENTMETADATAFLAG;

	return ret;
}

#ifdef __cplusplus
const cfdpSegmentMetadataFlag cfdpSegmentMetadataFlag_constant = SegmentMetadataFlag_flag_present;
#endif

void cfdpSegmentMetadataFlag_Initialize(cfdpSegmentMetadataFlag* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpSegmentMetadataFlag)cfdpSegmentMetadataFlag_constant;
}

flag cfdpSegmentMetadataFlag_Encode(const cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal)))
	    {
	        case SegmentMetadataFlag_flag_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case SegmentMetadataFlag_flag_not_present:
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SEGMENTMETADATAFLAG; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentMetadataFlag_Decode(cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SEGMENTMETADATAFLAG;
	    if (ret) {
	        switch(enumIndex)
	        {
	            case 0:
	                (*(pVal)) = SegmentMetadataFlag_flag_present;
	                break;
	            case 1:
	                (*(pVal)) = SegmentMetadataFlag_flag_not_present;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SEGMENTMETADATAFLAG;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = SegmentMetadataFlag_flag_present;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode);
}

flag cfdpSegmentMetadataFlag_ACN_Encode(const cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case SegmentMetadataFlag_flag_present:
	            intVal_pVal = 0UL;
	            break;
	        case SegmentMetadataFlag_flag_not_present:
	            intVal_pVal = 1UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SEGMENTMETADATAFLAG;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal, 1);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpSegmentMetadataFlag_ACN_Decode(cfdpSegmentMetadataFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint intVal_pVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal)), 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SEGMENTMETADATAFLAG;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = SegmentMetadataFlag_flag_present;
	            break;
	        case 1:
	            (*(pVal)) = SegmentMetadataFlag_flag_not_present;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SEGMENTMETADATAFLAG;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && cfdpSegmentMetadataFlag_IsConstraintValid(pVal, pErrCode);
}


flag cfdpLengthOfTransactionSequenceNumber_Equal(const cfdpLengthOfTransactionSequenceNumber* pVal1, const cfdpLengthOfTransactionSequenceNumber* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(const cfdpLengthOfTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpLengthOfTransactionSequenceNumber cfdpLengthOfTransactionSequenceNumber_constant = 0UL;
#endif

void cfdpLengthOfTransactionSequenceNumber_Initialize(cfdpLengthOfTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpLengthOfTransactionSequenceNumber)cfdpLengthOfTransactionSequenceNumber_constant;
}

flag cfdpLengthOfTransactionSequenceNumber_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

	return ret  && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Encode(const cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, (*(pVal)), 3);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpLengthOfTransactionSequenceNumber_ACN_Decode(cfdpLengthOfTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pVal, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LENGTHOFTRANSACTIONSEQUENCENUMBER;

    return ret && cfdpLengthOfTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpEntityId_Equal(const cfdpEntityId* pVal1, const cfdpEntityId* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpEntityId_IsConstraintValid(const cfdpEntityId* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_ENTITYID;

	return ret;
}

#ifdef __cplusplus
const cfdpEntityId cfdpEntityId_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpEntityId_Initialize(cfdpEntityId* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpEntityId)cfdpEntityId_constant;
}

flag cfdpEntityId_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}

flag cfdpEntityId_ACN_Encode(const cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpEntityId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpEntityId_ACN_Decode(cfdpEntityId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_ENTITYID;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpEntityId_IsConstraintValid(pVal, pErrCode);
}


flag cfdpTransactionSequenceNumber_Equal(const cfdpTransactionSequenceNumber* pVal1, const cfdpTransactionSequenceNumber* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpTransactionSequenceNumber_IsConstraintValid(const cfdpTransactionSequenceNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_TRANSACTIONSEQUENCENUMBER;

	return ret;
}

#ifdef __cplusplus
const cfdpTransactionSequenceNumber cfdpTransactionSequenceNumber_constant = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }};
#endif

void cfdpTransactionSequenceNumber_Initialize(cfdpTransactionSequenceNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpTransactionSequenceNumber)cfdpTransactionSequenceNumber_constant;
}

flag cfdpTransactionSequenceNumber_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}

flag cfdpTransactionSequenceNumber_ACN_Encode(const cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpTransactionSequenceNumber_ACN_Decode(cfdpTransactionSequenceNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TRANSACTIONSEQUENCENUMBER;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpTransactionSequenceNumber_IsConstraintValid(pVal, pErrCode);
}


flag cfdpPDUHeader_Equal(const cfdpPDUHeader* pVal1, const cfdpPDUHeader* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->version == pVal2->version);

    if (ret) {
        ret = (pVal1->direction == pVal2->direction);

        if (ret) {
            ret = (pVal1->transmission_mode == pVal2->transmission_mode);

            if (ret) {
                ret = (pVal1->crc_flag == pVal2->crc_flag);

                if (ret) {
                    ret = cfdpEntityId_Equal((&(pVal1->source_entity_id)), (&(pVal2->source_entity_id)));

                    if (ret) {
                        ret = cfdpTransactionSequenceNumber_Equal((&(pVal1->transaction_sequence_number)), (&(pVal2->transaction_sequence_number)));

                        if (ret) {
                            ret = cfdpEntityId_Equal((&(pVal1->destination_entity_id)), (&(pVal2->destination_entity_id)));

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag cfdpPDUHeader_IsConstraintValid(const cfdpPDUHeader* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpVersion_IsConstraintValid((&(pVal->version)), pErrCode);
    if (ret) {
        ret = cfdpDirection_IsConstraintValid((&(pVal->direction)), pErrCode);
        if (ret) {
            ret = cfdpTransmissionMode_IsConstraintValid((&(pVal->transmission_mode)), pErrCode);
            if (ret) {
                ret = cfdpCRCFlag_IsConstraintValid((&(pVal->crc_flag)), pErrCode);
                if (ret) {
                    ret = cfdpEntityId_IsConstraintValid((&(pVal->source_entity_id)), pErrCode);
                    if (ret) {
                        ret = cfdpTransactionSequenceNumber_IsConstraintValid((&(pVal->transaction_sequence_number)), pErrCode);
                        if (ret) {
                            ret = cfdpEntityId_IsConstraintValid((&(pVal->destination_entity_id)), pErrCode);
                        }   /*COVERAGE_IGNORE*/
                    }   /*COVERAGE_IGNORE*/
                }   /*COVERAGE_IGNORE*/
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpPDUHeader cfdpPDUHeader_constant = {.version = 0UL, .direction = Direction_toward_receiver, .transmission_mode = TransmissionMode_acknowledged, .crc_flag = CRCFlag_crc_not_present, .source_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .transaction_sequence_number = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}, .destination_entity_id = {.nCount = 1, .arr  = {[0 ... 7-1] = 0 }}};
#endif

void cfdpPDUHeader_Initialize(cfdpPDUHeader* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpPDUHeader)cfdpPDUHeader_constant;
}

flag cfdpPDUHeader_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpVersion_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode direction */
	        ret = cfdpDirection_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode transmission_mode */
	            ret = cfdpTransmissionMode_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode crc_flag */
	                ret = cfdpCRCFlag_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode source_entity_id */
	                    ret = cfdpEntityId_Encode((&(pVal->source_entity_id)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode transaction_sequence_number */
	                        ret = cfdpTransactionSequenceNumber_Encode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode destination_entity_id */
	                            ret = cfdpEntityId_Encode((&(pVal->destination_entity_id)), pBitStrm, pErrCode, FALSE);
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode version */
	ret = cfdpVersion_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode direction */
	    ret = cfdpDirection_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode transmission_mode */
	        ret = cfdpTransmissionMode_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode crc_flag */
	            ret = cfdpCRCFlag_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode source_entity_id */
	                ret = cfdpEntityId_Decode((&(pVal->source_entity_id)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode transaction_sequence_number */
	                    ret = cfdpTransactionSequenceNumber_Decode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode destination_entity_id */
	                        ret = cfdpEntityId_Decode((&(pVal->destination_entity_id)), pBitStrm, pErrCode);
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}

flag cfdpPDUHeader_ACN_Encode(const cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpPDUHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    ret = cfdpVersion_ACN_Encode((&(pVal->version)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode direction */
	        ret = cfdpDirection_ACN_Encode((&(pVal->direction)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode transmission_mode */
	            ret = cfdpTransmissionMode_ACN_Encode((&(pVal->transmission_mode)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode crc_flag */
	                ret = cfdpCRCFlag_ACN_Encode((&(pVal->crc_flag)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode source_entity_id */
	                    ret = cfdpEntityId_ACN_Encode((&(pVal->source_entity_id)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode transaction_sequence_number */
	                        ret = cfdpTransactionSequenceNumber_ACN_Encode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode destination_entity_id */
	                            ret = cfdpEntityId_ACN_Encode((&(pVal->destination_entity_id)), pBitStrm, pErrCode, FALSE);
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpPDUHeader_ACN_Decode(cfdpPDUHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode version */
	ret = cfdpVersion_ACN_Decode((&(pVal->version)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode direction */
	    ret = cfdpDirection_ACN_Decode((&(pVal->direction)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode transmission_mode */
	        ret = cfdpTransmissionMode_ACN_Decode((&(pVal->transmission_mode)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode crc_flag */
	            ret = cfdpCRCFlag_ACN_Decode((&(pVal->crc_flag)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode source_entity_id */
	                ret = cfdpEntityId_ACN_Decode((&(pVal->source_entity_id)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode transaction_sequence_number */
	                    ret = cfdpTransactionSequenceNumber_ACN_Decode((&(pVal->transaction_sequence_number)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode destination_entity_id */
	                        ret = cfdpEntityId_ACN_Decode((&(pVal->destination_entity_id)), pBitStrm, pErrCode);
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpPDUHeader_IsConstraintValid(pVal, pErrCode);
}


flag cfdpCfdpPDU_Equal(const cfdpCfdpPDU* pVal1, const cfdpCfdpPDU* pVal2)
{
	flag ret=TRUE;

    ret = cfdpPDUHeader_Equal((&(pVal1->pdu_header)), (&(pVal2->pdu_header)));

    if (ret) {
        ret = cfdpPayloadData_Equal((&(pVal1->payload)), (&(pVal2->payload)));

    }

	return ret;

}

flag cfdpCfdpPDU_IsConstraintValid(const cfdpCfdpPDU* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = cfdpPDUHeader_IsConstraintValid((&(pVal->pdu_header)), pErrCode);
    if (ret) {
        ret = cfdpPayloadData_IsConstraintValid((&(pVal->payload)), pErrCode);
    }   /*COVERAGE_IGNORE*/

	return ret;
}

#ifdef __cplusplus
const cfdpCfdpPDU cfdpCfdpPDU_constant = {.pdu_header = cfdpPDUHeader_constant, .payload = cfdpPayloadData_constant};
#endif

void cfdpCfdpPDU_Initialize(cfdpCfdpPDU* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpCfdpPDU)cfdpCfdpPDU_constant;
}

flag cfdpCfdpPDU_Encode(const cfdpCfdpPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpCfdpPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode pdu_header */
	    ret = cfdpPDUHeader_Encode((&(pVal->pdu_header)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode payload */
	        /*open new scope to declare some variables*/
	        {
	        	/*encode to a temporary bitstream*/
	        	static byte arr[cfdpPayloadData_REQUIRED_BYTES_FOR_ENCODING];
	        	BitStream bitStrm;
	        	BitStream_Init(&bitStrm, arr, sizeof(arr));

	        	ret = cfdpPayloadData_Encode((&(pVal->payload)), &bitStrm, pErrCode, FALSE);
	        	if (ret) {
	        		int nCount = bitStrm.currentBit == 0 ? bitStrm.currentByte : (bitStrm.currentByte + 1);
	        		ret = BitStream_EncodeOctetString(pBitStrm, arr, nCount, 2, 4102);
	        	}
	        }
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCfdpPDU_Decode(cfdpCfdpPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pdu_header */
	ret = cfdpPDUHeader_Decode((&(pVal->pdu_header)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode payload */
	    /*open new scope to declare some variables*/
	    {
	    	/*decode to a temporary bitstream*/
	    	static byte arr[cfdpPayloadData_REQUIRED_BYTES_FOR_ENCODING];
	    	BitStream bitStrm;
	    	BitStream_Init(&bitStrm, arr, sizeof(arr));
	    	int nCount;
	    	ret = BitStream_DecodeOctetString(pBitStrm, arr, &nCount, 2, 4102);
	    	if (ret) {
	    		ret = cfdpPayloadData_Decode((&(pVal->payload)), &bitStrm, pErrCode);
	    	}
	    }
	}   /*COVERAGE_IGNORE*/

	return ret  && cfdpCfdpPDU_IsConstraintValid(pVal, pErrCode);
}

flag cfdpCfdpPDU_ACN_Encode(const cfdpCfdpPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint CfdpPDU_pdu_header_pdu_type;
	flag CfdpPDU_pdu_header_pdu_type_is_initialized=FALSE;
	asn1SccUint CfdpPDU_pdu_header_pdu_data_field_length;
	flag CfdpPDU_pdu_header_pdu_data_field_length_is_initialized=FALSE;
	asn1SccUint CfdpPDU_pdu_header_length_of_entity_ids;
	flag CfdpPDU_pdu_header_length_of_entity_ids_is_initialized=FALSE;
	asn1SccUint CfdpPDU_pdu_header_length_of_transaction_sequence_number;
	flag CfdpPDU_pdu_header_length_of_transaction_sequence_number_is_initialized=FALSE;
	asn1SccUint intVal_pVal_pdu_header_direction;
	asn1SccUint intVal_pVal_pdu_header_transmission_mode;
	asn1SccUint intVal_pVal_pdu_header_crc_flag;
	asn1SccUint CfdpPDU_payload_file_directive_directive_code;
	flag CfdpPDU_payload_file_directive_directive_code_is_initialized=FALSE;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_finished_pdu_file_status;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status;
	asn1SccUint CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size;
	flag CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized=FALSE;
	asn1SccUint CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size;
	flag CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized=FALSE;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested;
	asn1SccUint intVal_dummy_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type;
	static byte arr[cfdpPayloadData_REQUIRED_BYTES_FOR_ACN_ENCODING];
	BitStream bitStrm;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type;
    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpCfdpPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode pdu_header */
	    /*Encode version */
	    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, pVal->pdu_header.version, 3);
	    if (ret) {
	        switch (pVal->payload.kind) {
	            case PayloadData_file_directive_PRESENT:
	            		CfdpPDU_pdu_header_pdu_type_is_initialized = TRUE;
	            		CfdpPDU_pdu_header_pdu_type = 0;
	                break;
	            case PayloadData_file_data_PRESENT:
	            		CfdpPDU_pdu_header_pdu_type_is_initialized = TRUE;
	            		CfdpPDU_pdu_header_pdu_type = 1;
	                break;
	            default:
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	        }
	        if (ret) {
	            /*Encode CfdpPDU_pdu_header_pdu_type */
	            if (CfdpPDU_pdu_header_pdu_type_is_initialized) {
	                ret = TRUE;
	                Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, CfdpPDU_pdu_header_pdu_type, 1);
	            } else {
	                *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_PDU_TYPE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                ret = FALSE;                    /*COVERAGE_IGNORE*/
	            }
	        }   /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Encode direction */
	            switch(pVal->pdu_header.direction) {
	                case Direction_toward_receiver:
	                    intVal_pVal_pdu_header_direction = 0UL;
	                    break;
	                case Direction_toward_sender:
	                    intVal_pVal_pdu_header_direction = 1UL;
	                    break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_DIRECTION;                 /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_pdu_header_direction, 1);
	            }
	            if (ret) {
	                /*Encode transmission_mode */
	                switch(pVal->pdu_header.transmission_mode) {
	                    case TransmissionMode_acknowledged:
	                        intVal_pVal_pdu_header_transmission_mode = 0UL;
	                        break;
	                    case TransmissionMode_unacknowledged:
	                        intVal_pVal_pdu_header_transmission_mode = 1UL;
	                        break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_TRANSMISSION_MODE;                 /*COVERAGE_IGNORE*/
	                }
	                if (ret) {
	                	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_pdu_header_transmission_mode, 1);
	                }
	                if (ret) {
	                    /*Encode crc_flag */
	                    switch(pVal->pdu_header.crc_flag) {
	                        case CRCFlag_crc_not_present:
	                            intVal_pVal_pdu_header_crc_flag = 0UL;
	                            break;
	                        case CRCFlag_crc_present:
	                            intVal_pVal_pdu_header_crc_flag = 1UL;
	                            break;
	                        default:                                    /*COVERAGE_IGNORE*/
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_CRC_FLAG;                 /*COVERAGE_IGNORE*/
	                    }
	                    if (ret) {
	                    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_pdu_header_crc_flag, 1);
	                    }
	                    if (ret) {
	                        /*Encode CfdpPDU_pdu_header_large_file_flag */
	                        {
	                        	static byte tmp[] = {0x00};
	                        	BitStream_AppendBits(pBitStrm, tmp, 1);
	                        }
	                        if (ret) {
	                            {
	                                /*first encode containing type to a temporary bitstream. That's the only way to learn in advance the size of the encoding octet string*/
	                                BitStream_Init(&bitStrm, arr, sizeof(arr));
	                                BitStream* pBitStrm_save = pBitStrm;
	                                pBitStrm = &bitStrm;
	                                switch(pVal->payload.kind)
	                                {
	                                case PayloadData_file_directive_PRESENT:
	                                	if (pVal->payload.kind == PayloadData_file_directive_PRESENT) {
	                                	    switch (pVal->payload.u.file_directive.file_directive_pdu.kind) {
	                                	        case FileDirectivePDU_eof_pdu_PRESENT:
	                                	        		CfdpPDU_payload_file_directive_directive_code_is_initialized = TRUE;
	                                	        		CfdpPDU_payload_file_directive_directive_code = 4;
	                                	            break;
	                                	        case FileDirectivePDU_finished_pdu_PRESENT:
	                                	        		CfdpPDU_payload_file_directive_directive_code_is_initialized = TRUE;
	                                	        		CfdpPDU_payload_file_directive_directive_code = 5;
	                                	            break;
	                                	        case FileDirectivePDU_ack_pdu_PRESENT:
	                                	        		CfdpPDU_payload_file_directive_directive_code_is_initialized = TRUE;
	                                	        		CfdpPDU_payload_file_directive_directive_code = 6;
	                                	            break;
	                                	        case FileDirectivePDU_metadata_pdu_PRESENT:
	                                	        		CfdpPDU_payload_file_directive_directive_code_is_initialized = TRUE;
	                                	        		CfdpPDU_payload_file_directive_directive_code = 7;
	                                	            break;
	                                	        default:
	                                	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    }
	                                	}
	                                	if (ret) {
	                                	    /*Encode CfdpPDU_payload_file_directive_directive_code */
	                                	    if (CfdpPDU_payload_file_directive_directive_code_is_initialized) {
	                                	        ret = TRUE;
	                                	        Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, CfdpPDU_payload_file_directive_directive_code);
	                                	    } else {
	                                	        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_DIRECTIVE_CODE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                	    }
	                                	}   /*COVERAGE_IGNORE*/
	                                	if (ret) {
	                                	    /*Encode file_directive_pdu */
	                                	    switch(pVal->payload.u.file_directive.file_directive_pdu.kind)
	                                	    {
	                                	    case FileDirectivePDU_eof_pdu_PRESENT:
	                                	    	/*Encode condition_code */
	                                	    	switch(pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code) {
	                                	    	    case ConditionCode_no_error:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 0UL;
	                                	    	        break;
	                                	    	    case ConditionCode_positive_ack_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 1UL;
	                                	    	        break;
	                                	    	    case ConditionCode_keep_alive_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 2UL;
	                                	    	        break;
	                                	    	    case ConditionCode_invalid_transmission_mode:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 3UL;
	                                	    	        break;
	                                	    	    case ConditionCode_filestore_rejection:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 4UL;
	                                	    	        break;
	                                	    	    case ConditionCode_file_checksum_failure:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 5UL;
	                                	    	        break;
	                                	    	    case ConditionCode_file_size_error:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 6UL;
	                                	    	        break;
	                                	    	    case ConditionCode_nak_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 7UL;
	                                	    	        break;
	                                	    	    case ConditionCode_inactivity_detected:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 8UL;
	                                	    	        break;
	                                	    	    case ConditionCode_invalid_file_structure:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 9UL;
	                                	    	        break;
	                                	    	    case ConditionCode_check_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 10UL;
	                                	    	        break;
	                                	    	    case ConditionCode_unsupported_checksum_type:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 11UL;
	                                	    	        break;
	                                	    	    case ConditionCode_suspend_request_received:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 12UL;
	                                	    	        break;
	                                	    	    case ConditionCode_cancel_request_received:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code = 13UL;
	                                	    	        break;
	                                	    	    default:                                    /*COVERAGE_IGNORE*/
	                                	    	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                	    	}
	                                	    	if (ret) {
	                                	    		Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code, 4);
	                                	    	}
	                                	    	if (ret) {
	                                	    	    /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_eof_pdu_spare */
	                                	    	    {
	                                	    	    	static byte tmp[] = {0x00};
	                                	    	    	BitStream_AppendBits(pBitStrm, tmp, 4);
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	        /*Encode file_checksum */
	                                	    	        Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.file_checksum);
	                                	    	        if (ret) {
	                                	    	            /*Encode file_size */
	                                	    	            Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.file_size);
	                                	    	        }   /*COVERAGE_IGNORE*/
	                                	    	    }   /*COVERAGE_IGNORE*/
	                                	    	}   /*COVERAGE_IGNORE*/
	                                	    	break;
	                                	    case FileDirectivePDU_finished_pdu_PRESENT:
	                                	    	/*Encode condition_code */
	                                	    	switch(pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code) {
	                                	    	    case ConditionCode_no_error:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 0UL;
	                                	    	        break;
	                                	    	    case ConditionCode_positive_ack_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 1UL;
	                                	    	        break;
	                                	    	    case ConditionCode_keep_alive_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 2UL;
	                                	    	        break;
	                                	    	    case ConditionCode_invalid_transmission_mode:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 3UL;
	                                	    	        break;
	                                	    	    case ConditionCode_filestore_rejection:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 4UL;
	                                	    	        break;
	                                	    	    case ConditionCode_file_checksum_failure:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 5UL;
	                                	    	        break;
	                                	    	    case ConditionCode_file_size_error:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 6UL;
	                                	    	        break;
	                                	    	    case ConditionCode_nak_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 7UL;
	                                	    	        break;
	                                	    	    case ConditionCode_inactivity_detected:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 8UL;
	                                	    	        break;
	                                	    	    case ConditionCode_invalid_file_structure:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 9UL;
	                                	    	        break;
	                                	    	    case ConditionCode_check_limit_reached:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 10UL;
	                                	    	        break;
	                                	    	    case ConditionCode_unsupported_checksum_type:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 11UL;
	                                	    	        break;
	                                	    	    case ConditionCode_suspend_request_received:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 12UL;
	                                	    	        break;
	                                	    	    case ConditionCode_cancel_request_received:
	                                	    	        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code = 13UL;
	                                	    	        break;
	                                	    	    default:                                    /*COVERAGE_IGNORE*/
	                                	    	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                	    	}
	                                	    	if (ret) {
	                                	    		Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code, 4);
	                                	    	}
	                                	    	if (ret) {
	                                	    	    /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_finished_pdu_end_system_status */
	                                	    	    {
	                                	    	    	static byte tmp[] = {0x80};
	                                	    	    	BitStream_AppendBits(pBitStrm, tmp, 1);
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	        /*Encode delivery_code */
	                                	    	        switch(pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.delivery_code) {
	                                	    	            case DeliveryCode_data_complete:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code = 0UL;
	                                	    	                break;
	                                	    	            case DeliveryCode_data_incomplete:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code = 1UL;
	                                	    	                break;
	                                	    	            default:                                    /*COVERAGE_IGNORE*/
	                                	    	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	                *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	                                	    	        }
	                                	    	        if (ret) {
	                                	    	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code, 1);
	                                	    	        }
	                                	    	        if (ret) {
	                                	    	            /*Encode file_status */
	                                	    	            switch(pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.file_status) {
	                                	    	                case FileStatus_discarted_deliberately:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status = 0UL;
	                                	    	                    break;
	                                	    	                case FileStatus_discarted_file_rejection:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status = 1UL;
	                                	    	                    break;
	                                	    	                case FileStatus_retained_successfully:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status = 2UL;
	                                	    	                    break;
	                                	    	                case FileStatus_unreported:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status = 3UL;
	                                	    	                    break;
	                                	    	                default:                                    /*COVERAGE_IGNORE*/
	                                	    	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	                                	    	            }
	                                	    	            if (ret) {
	                                	    	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status, 2);
	                                	    	            }
	                                	    	        }   /*COVERAGE_IGNORE*/
	                                	    	    }   /*COVERAGE_IGNORE*/
	                                	    	}   /*COVERAGE_IGNORE*/
	                                	    	break;
	                                	    case FileDirectivePDU_ack_pdu_PRESENT:
	                                	    	/*Encode directive_code_of_ack_pdu */
	                                	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.directive_code_of_ack_pdu);
	                                	    	if (ret) {
	                                	    	    /*Encode directive_subtype_code */
	                                	    	    switch(pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.directive_subtype_code) {
	                                	    	        case DirectiveSubtypeCode_ack_others:
	                                	    	            intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code = 0UL;
	                                	    	            break;
	                                	    	        case DirectiveSubtypeCode_ack_finished:
	                                	    	            intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code = 1UL;
	                                	    	            break;
	                                	    	        default:                                    /*COVERAGE_IGNORE*/
	                                	    	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	            *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code, 4);
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	        /*Encode condition_code */
	                                	    	        switch(pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code) {
	                                	    	            case ConditionCode_no_error:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 0UL;
	                                	    	                break;
	                                	    	            case ConditionCode_positive_ack_limit_reached:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 1UL;
	                                	    	                break;
	                                	    	            case ConditionCode_keep_alive_limit_reached:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 2UL;
	                                	    	                break;
	                                	    	            case ConditionCode_invalid_transmission_mode:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 3UL;
	                                	    	                break;
	                                	    	            case ConditionCode_filestore_rejection:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 4UL;
	                                	    	                break;
	                                	    	            case ConditionCode_file_checksum_failure:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 5UL;
	                                	    	                break;
	                                	    	            case ConditionCode_file_size_error:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 6UL;
	                                	    	                break;
	                                	    	            case ConditionCode_nak_limit_reached:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 7UL;
	                                	    	                break;
	                                	    	            case ConditionCode_inactivity_detected:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 8UL;
	                                	    	                break;
	                                	    	            case ConditionCode_invalid_file_structure:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 9UL;
	                                	    	                break;
	                                	    	            case ConditionCode_check_limit_reached:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 10UL;
	                                	    	                break;
	                                	    	            case ConditionCode_unsupported_checksum_type:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 11UL;
	                                	    	                break;
	                                	    	            case ConditionCode_suspend_request_received:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 12UL;
	                                	    	                break;
	                                	    	            case ConditionCode_cancel_request_received:
	                                	    	                intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code = 13UL;
	                                	    	                break;
	                                	    	            default:                                    /*COVERAGE_IGNORE*/
	                                	    	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	                *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                	    	        }
	                                	    	        if (ret) {
	                                	    	        	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code, 4);
	                                	    	        }
	                                	    	        if (ret) {
	                                	    	            /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_ack_pdu_spare */
	                                	    	            {
	                                	    	            	static byte tmp[] = {0x00};
	                                	    	            	BitStream_AppendBits(pBitStrm, tmp, 2);
	                                	    	            }
	                                	    	            if (ret) {
	                                	    	                /*Encode transaction_status */
	                                	    	                switch(pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.transaction_status) {
	                                	    	                    case AckTransactionStatus_undefined:
	                                	    	                        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status = 0UL;
	                                	    	                        break;
	                                	    	                    case AckTransactionStatus_active:
	                                	    	                        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status = 1UL;
	                                	    	                        break;
	                                	    	                    case AckTransactionStatus_terminated:
	                                	    	                        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status = 2UL;
	                                	    	                        break;
	                                	    	                    case AckTransactionStatus_unrecognized:
	                                	    	                        intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status = 3UL;
	                                	    	                        break;
	                                	    	                    default:                                    /*COVERAGE_IGNORE*/
	                                	    	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	                        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	                                	    	                }
	                                	    	                if (ret) {
	                                	    	                	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status, 2);
	                                	    	                }
	                                	    	            }   /*COVERAGE_IGNORE*/
	                                	    	        }   /*COVERAGE_IGNORE*/
	                                	    	    }   /*COVERAGE_IGNORE*/
	                                	    	}   /*COVERAGE_IGNORE*/
	                                	    	break;
	                                	    case FileDirectivePDU_metadata_pdu_PRESENT:
	                                	    	/*Encode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_reserved1 */
	                                	    	{
	                                	    		static byte tmp[] = {0x00};
	                                	    		BitStream_AppendBits(pBitStrm, tmp, 1);
	                                	    	}
	                                	    	if (ret) {
	                                	    	    /*Encode closure_requested */
	                                	    	    switch(pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.closure_requested) {
	                                	    	        case ClosureRequested_requested:
	                                	    	            intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested = 0UL;
	                                	    	            break;
	                                	    	        case ClosureRequested_not_requested:
	                                	    	            intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested = 1UL;
	                                	    	            break;
	                                	    	        default:                                    /*COVERAGE_IGNORE*/
	                                	    	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	            *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	    	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested, 1);
	                                	    	    }
	                                	    	    if (ret) {
	                                	    	        /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_reserved2 */
	                                	    	        {
	                                	    	        	static byte tmp[] = {0x00};
	                                	    	        	BitStream_AppendBits(pBitStrm, tmp, 2);
	                                	    	        }
	                                	    	        if (ret) {
	                                	    	            /*Encode checksum_type */
	                                	    	            switch(pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.checksum_type) {
	                                	    	                case ChecksumType_modular:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type = 0UL;
	                                	    	                    break;
	                                	    	                case ChecksumType_none:
	                                	    	                    intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type = 1UL;
	                                	    	                    break;
	                                	    	                default:                                    /*COVERAGE_IGNORE*/
	                                	    	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                	    	                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	                                	    	            }
	                                	    	            if (ret) {
	                                	    	            	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type, 4);
	                                	    	            }
	                                	    	            if (ret) {
	                                	    	                /*Encode file_size */
	                                	    	                Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.file_size);
	                                	    	                if (ret) {
	                                	    	                    if (pVal->payload.u.file_directive.file_directive_pdu.kind == FileDirectivePDU_metadata_pdu_PRESENT && pVal->payload.kind == PayloadData_file_directive_PRESENT) {
	                                	    	                        CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized = TRUE;
	                                	    	                        CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size = pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.nCount;
	                                	    	                    }
	                                	    	                    if (ret) {
	                                	    	                        /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size */
	                                	    	                        if (CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size_is_initialized) {
	                                	    	                            ret = TRUE;
	                                	    	                            Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size);
	                                	    	                        } else {
	                                	    	                            *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                	    	                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                	    	                        }
	                                	    	                    }   /*COVERAGE_IGNORE*/
	                                	    	                    if (ret) {
	                                	    	                        /*Encode source_file_name */
	                                	    	                        ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.arr, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.nCount);
	                                	    	                        if (ret) {
	                                	    	                            if (pVal->payload.u.file_directive.file_directive_pdu.kind == FileDirectivePDU_metadata_pdu_PRESENT && pVal->payload.kind == PayloadData_file_directive_PRESENT) {
	                                	    	                                CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized = TRUE;
	                                	    	                                CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size = pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.nCount;
	                                	    	                            }
	                                	    	                            if (ret) {
	                                	    	                                /*Encode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size */
	                                	    	                                if (CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size_is_initialized) {
	                                	    	                                    ret = TRUE;
	                                	    	                                    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size);
	                                	    	                                } else {
	                                	    	                                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME_SIZE_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                	    	                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                	    	                                }
	                                	    	                            }   /*COVERAGE_IGNORE*/
	                                	    	                            if (ret) {
	                                	    	                                /*Encode destination_file_name */
	                                	    	                                ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.arr, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.nCount);
	                                	    	                            }   /*COVERAGE_IGNORE*/
	                                	    	                        }   /*COVERAGE_IGNORE*/
	                                	    	                    }   /*COVERAGE_IGNORE*/
	                                	    	                }   /*COVERAGE_IGNORE*/
	                                	    	            }   /*COVERAGE_IGNORE*/
	                                	    	        }   /*COVERAGE_IGNORE*/
	                                	    	    }   /*COVERAGE_IGNORE*/
	                                	    	}   /*COVERAGE_IGNORE*/
	                                	    	break;
	                                	    default:
	                                	        *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU;         /*COVERAGE_IGNORE*/
	                                	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                	    }
	                                	}   /*COVERAGE_IGNORE*/
	                                	break;
	                                case PayloadData_file_data_PRESENT:
	                                	/*Encode file_data_pdu */
	                                	ret = cfdpFileDataPDU_ACN_Encode((&(pVal->payload.u.file_data.file_data_pdu)), pBitStrm, pErrCode, FALSE);
	                                	break;
	                                default:
	                                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PAYLOAD;         /*COVERAGE_IGNORE*/
	                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                }
	                                pBitStrm = pBitStrm_save;
	                              //ret = cfdpPayloadData_ACN_Encode((&(pVal->payload)), &bitStrm, pErrCode, FALSE);
	                            }
	                            if (ret) {
	                            	CfdpPDU_pdu_header_pdu_data_field_length = bitStrm.currentBit == 0 ? bitStrm.currentByte : (bitStrm.currentByte + 1);
	                            	CfdpPDU_pdu_header_pdu_data_field_length_is_initialized = TRUE;
	                            }

	                            if (ret) {
	                                /*Encode CfdpPDU_pdu_header_pdu_data_field_length */
	                                if (CfdpPDU_pdu_header_pdu_data_field_length_is_initialized) {
	                                    ret = TRUE;
	                                    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, CfdpPDU_pdu_header_pdu_data_field_length);
	                                } else {
	                                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_PDU_DATA_FIELD_LENGTH_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                }
	                            }   /*COVERAGE_IGNORE*/
	                            if (ret) {
	                                /*Encode CfdpPDU_pdu_header_segmentation_control */
	                                {
	                                	static byte tmp[] = {0x00};
	                                	BitStream_AppendBits(pBitStrm, tmp, 1);
	                                }
	                                if (ret) {
	                                    {
	                                        asn1SccUint CfdpPDU_pdu_header_length_of_entity_ids00;
	                                        flag CfdpPDU_pdu_header_length_of_entity_ids00_is_initialized=FALSE;
	                                        asn1SccUint CfdpPDU_pdu_header_length_of_entity_ids01;
	                                        flag CfdpPDU_pdu_header_length_of_entity_ids01_is_initialized=FALSE;

	                                        CfdpPDU_pdu_header_length_of_entity_ids00_is_initialized = TRUE;
	                                        CfdpPDU_pdu_header_length_of_entity_ids00 = pVal->pdu_header.destination_entity_id.nCount;
	                                        CfdpPDU_pdu_header_length_of_entity_ids01_is_initialized = TRUE;
	                                        CfdpPDU_pdu_header_length_of_entity_ids01 = pVal->pdu_header.source_entity_id.nCount;

	                                        if (ret) {

	                                            *pErrCode = ERR_ACN_ENCODE_UPDATE_CFDPPDU_PDU_HEADER_LENGTH_OF_ENTITY_IDS;
	                                            if (CfdpPDU_pdu_header_length_of_entity_ids00_is_initialized) { /*COVERAGE_IGNORE*/
	                                                CfdpPDU_pdu_header_length_of_entity_ids = CfdpPDU_pdu_header_length_of_entity_ids00; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else if (CfdpPDU_pdu_header_length_of_entity_ids01_is_initialized) { /*COVERAGE_IGNORE*/
	                                                CfdpPDU_pdu_header_length_of_entity_ids = CfdpPDU_pdu_header_length_of_entity_ids01; /*COVERAGE_IGNORE*/
	                                            } /*COVERAGE_IGNORE*/ else {
	                                                ret = FALSE; /*COVERAGE_IGNORE*/
	                                            }
	                                            if (ret) {
	                                                ret = (((CfdpPDU_pdu_header_length_of_entity_ids00_is_initialized && CfdpPDU_pdu_header_length_of_entity_ids == CfdpPDU_pdu_header_length_of_entity_ids00) || !CfdpPDU_pdu_header_length_of_entity_ids00_is_initialized) && ((CfdpPDU_pdu_header_length_of_entity_ids01_is_initialized && CfdpPDU_pdu_header_length_of_entity_ids == CfdpPDU_pdu_header_length_of_entity_ids01) || !CfdpPDU_pdu_header_length_of_entity_ids01_is_initialized));
	                                                CfdpPDU_pdu_header_length_of_entity_ids_is_initialized = TRUE;
	                                            }
	                                        }
	                                    }
	                                    if (ret) {
	                                        /*Encode CfdpPDU_pdu_header_length_of_entity_ids */
	                                        if (CfdpPDU_pdu_header_length_of_entity_ids_is_initialized) {
	                                            ret = TRUE;
	                                            Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, cfdp_entity_len_encode(CfdpPDU_pdu_header_length_of_entity_ids), 3);
	                                        } else {
	                                            *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_LENGTH_OF_ENTITY_IDS_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                        }
	                                    }   /*COVERAGE_IGNORE*/
	                                    if (ret) {
	                                        /*Encode CfdpPDU_pdu_header_segment_metadata_flag */
	                                        {
	                                        	static byte tmp[] = {0x00};
	                                        	BitStream_AppendBits(pBitStrm, tmp, 1);
	                                        }
	                                        if (ret) {
	                                            CfdpPDU_pdu_header_length_of_transaction_sequence_number_is_initialized = TRUE;
	                                            CfdpPDU_pdu_header_length_of_transaction_sequence_number = pVal->pdu_header.transaction_sequence_number.nCount;
	                                            if (ret) {
	                                                /*Encode CfdpPDU_pdu_header_length_of_transaction_sequence_number */
	                                                if (CfdpPDU_pdu_header_length_of_transaction_sequence_number_is_initialized) {
	                                                    ret = TRUE;
	                                                    Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, cfdp_entity_len_encode(CfdpPDU_pdu_header_length_of_transaction_sequence_number), 3);
	                                                } else {
	                                                    *pErrCode = ERR_ACN_ENCODE_CFDPPDU_PDU_HEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                                                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                                                }
	                                            }   /*COVERAGE_IGNORE*/
	                                            if (ret) {
	                                                /*Encode source_entity_id */
	                                                ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->pdu_header.source_entity_id.arr, pVal->pdu_header.source_entity_id.nCount);
	                                                if (ret) {
	                                                    /*Encode transaction_sequence_number */
	                                                    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->pdu_header.transaction_sequence_number.arr, pVal->pdu_header.transaction_sequence_number.nCount);
	                                                    if (ret) {
	                                                        /*Encode destination_entity_id */
	                                                        ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->pdu_header.destination_entity_id.arr, pVal->pdu_header.destination_entity_id.nCount);
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	    if (ret) {
	        /*Encode payload */
	        ret = BitStream_EncodeOctetString_no_length(pBitStrm, arr, (int)CfdpPDU_pdu_header_pdu_data_field_length);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpCfdpPDU_ACN_Decode(cfdpCfdpPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint CfdpPDU_pdu_header_pdu_type;
	asn1SccUint CfdpPDU_pdu_header_pdu_data_field_length;
	asn1SccUint CfdpPDU_pdu_header_length_of_entity_ids;
	asn1SccUint CfdpPDU_pdu_header_length_of_transaction_sequence_number;
	asn1SccUint intVal_pVal_pdu_header_direction;
	asn1SccUint intVal_pVal_pdu_header_transmission_mode;
	asn1SccUint intVal_pVal_pdu_header_crc_flag;
	asn1SccUint CfdpPDU_payload_file_directive_directive_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status;
	asn1SccUint CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size;
	asn1SccUint CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested;
	asn1SccUint intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type;

	/*Decode pdu_header */
	/*Decode version */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(pVal->pdu_header.version)), 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_VERSION;
	if (ret) {
	    /*Decode CfdpPDU_pdu_header_pdu_type */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(CfdpPDU_pdu_header_pdu_type)), 1);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_PDU_TYPE;
	    if (ret) {
	        /*Decode direction */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_pdu_header_direction)), 1);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_DIRECTION;
	        if (ret) {
	            switch (intVal_pVal_pdu_header_direction) {
	                case 0:
	                    pVal->pdu_header.direction = Direction_toward_receiver;
	                    break;
	                case 1:
	                    pVal->pdu_header.direction = Direction_toward_sender;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_DIRECTION;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode transmission_mode */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_pdu_header_transmission_mode)), 1);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_TRANSMISSION_MODE;
	            if (ret) {
	                switch (intVal_pVal_pdu_header_transmission_mode) {
	                    case 0:
	                        pVal->pdu_header.transmission_mode = TransmissionMode_acknowledged;
	                        break;
	                    case 1:
	                        pVal->pdu_header.transmission_mode = TransmissionMode_unacknowledged;
	                        break;
	                default:                                    /*COVERAGE_IGNORE*/
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_TRANSMISSION_MODE;                 /*COVERAGE_IGNORE*/
	                }
	            } /*COVERAGE_IGNORE*/
	            if (ret) {
	                /*Decode crc_flag */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_pdu_header_crc_flag)), 1);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_CRC_FLAG;
	                if (ret) {
	                    switch (intVal_pVal_pdu_header_crc_flag) {
	                        case 0:
	                            pVal->pdu_header.crc_flag = CRCFlag_crc_not_present;
	                            break;
	                        case 1:
	                            pVal->pdu_header.crc_flag = CRCFlag_crc_present;
	                            break;
	                    default:                                    /*COVERAGE_IGNORE*/
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_CRC_FLAG;                 /*COVERAGE_IGNORE*/
	                    }
	                } /*COVERAGE_IGNORE*/
	                if (ret) {
	                    /*Decode CfdpPDU_pdu_header_large_file_flag */
	                    {
	                    	static byte tmp[] = {0x00};
	                        flag bDecodingPatternMatches;
	                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                        ret = ret && bDecodingPatternMatches;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_LARGE_FILE_FLAG;
	                    }

	                    if (ret) {
	                        /*Decode CfdpPDU_pdu_header_pdu_data_field_length */
	                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, (&(CfdpPDU_pdu_header_pdu_data_field_length)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_PDU_DATA_FIELD_LENGTH;
	                        if (ret) {
	                            /*Decode CfdpPDU_pdu_header_segmentation_control */
	                            {
	                            	static byte tmp[] = {0x00};
	                                flag bDecodingPatternMatches;
	                            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                ret = ret && bDecodingPatternMatches;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_SEGMENTATION_CONTROL;
	                            }

	                            if (ret) {
	                                /*Decode CfdpPDU_pdu_header_length_of_entity_ids */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(CfdpPDU_pdu_header_length_of_entity_ids)), 3);
	                                if (ret) {
	                                    *(&(CfdpPDU_pdu_header_length_of_entity_ids)) = cfdp_entity_len_decode(*(&(CfdpPDU_pdu_header_length_of_entity_ids)));
	                                }

	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_LENGTH_OF_ENTITY_IDS;
	                                if (ret) {
	                                    /*Decode CfdpPDU_pdu_header_segment_metadata_flag */
	                                    {
	                                    	static byte tmp[] = {0x00};
	                                        flag bDecodingPatternMatches;
	                                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                        ret = ret && bDecodingPatternMatches;
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_SEGMENT_METADATA_FLAG;
	                                    }

	                                    if (ret) {
	                                        /*Decode CfdpPDU_pdu_header_length_of_transaction_sequence_number */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(CfdpPDU_pdu_header_length_of_transaction_sequence_number)), 3);
	                                        if (ret) {
	                                            *(&(CfdpPDU_pdu_header_length_of_transaction_sequence_number)) = cfdp_entity_len_decode(*(&(CfdpPDU_pdu_header_length_of_transaction_sequence_number)));
	                                        }

	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_LENGTH_OF_TRANSACTION_SEQUENCE_NUMBER;
	                                        if (ret) {
	                                            /*Decode source_entity_id */
	                                            ret = ((1<=CfdpPDU_pdu_header_length_of_entity_ids) && (CfdpPDU_pdu_header_length_of_entity_ids<=7));
	                                            if (ret) {
	                                                pVal->pdu_header.source_entity_id.nCount = (int)CfdpPDU_pdu_header_length_of_entity_ids;
	                                                ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->pdu_header.source_entity_id.arr, pVal->pdu_header.source_entity_id.nCount);
	                                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_SOURCE_ENTITY_ID;
	                                            }
	                                            if (ret) {
	                                                /*Decode transaction_sequence_number */
	                                                ret = ((1<=CfdpPDU_pdu_header_length_of_transaction_sequence_number) && (CfdpPDU_pdu_header_length_of_transaction_sequence_number<=7));
	                                                if (ret) {
	                                                    pVal->pdu_header.transaction_sequence_number.nCount = (int)CfdpPDU_pdu_header_length_of_transaction_sequence_number;
	                                                    ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->pdu_header.transaction_sequence_number.arr, pVal->pdu_header.transaction_sequence_number.nCount);
	                                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_TRANSACTION_SEQUENCE_NUMBER;
	                                                }
	                                                if (ret) {
	                                                    /*Decode destination_entity_id */
	                                                    ret = ((1<=CfdpPDU_pdu_header_length_of_entity_ids) && (CfdpPDU_pdu_header_length_of_entity_ids<=7));
	                                                    if (ret) {
	                                                        pVal->pdu_header.destination_entity_id.nCount = (int)CfdpPDU_pdu_header_length_of_entity_ids;
	                                                        ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->pdu_header.destination_entity_id.arr, pVal->pdu_header.destination_entity_id.nCount);
	                                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PDU_HEADER_DESTINATION_ENTITY_ID;
	                                                    }
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode payload */
	    /*open new scope to declare some variables*/
	    {
	    	/*decode to a temporary bitstream*/
	    	static byte arr[cfdpPayloadData_REQUIRED_BYTES_FOR_ACN_ENCODING];
	        BitStream* pBitStrm_save = pBitStrm;
	    	BitStream bitStrm;
	    	BitStream_Init(&bitStrm, arr, sizeof(arr));
	    	ret = (int)CfdpPDU_pdu_header_pdu_data_field_length <= cfdpPayloadData_REQUIRED_BYTES_FOR_ACN_ENCODING;
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_2;
	    	if (ret) {
	    		ret = BitStream_DecodeOctetString_no_length(pBitStrm, arr, (int)CfdpPDU_pdu_header_pdu_data_field_length);
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_2;
	    		if (ret) {
	                pBitStrm = &bitStrm;
	                *pErrCode = 0;
	                if ((CfdpPDU_pdu_header_pdu_type == 0)) {
	                    pVal->payload.kind = PayloadData_file_directive_PRESENT;
	                    /*Decode CfdpPDU_payload_file_directive_directive_code */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(CfdpPDU_payload_file_directive_directive_code)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_DIRECTIVE_CODE;
	                    if (ret) {
	                        /*Decode file_directive_pdu */
	                        *pErrCode = 0;
	                        if ((CfdpPDU_payload_file_directive_directive_code == 4)) {
	                            pVal->payload.u.file_directive.file_directive_pdu.kind = FileDirectivePDU_eof_pdu_PRESENT;
	                            /*Decode condition_code */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code)), 4);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;
	                            if (ret) {
	                                switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_eof_pdu_condition_code) {
	                                    case 0:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_no_error;
	                                        break;
	                                    case 1:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                                        break;
	                                    case 2:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                                        break;
	                                    case 3:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                                        break;
	                                    case 4:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_filestore_rejection;
	                                        break;
	                                    case 5:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_file_checksum_failure;
	                                        break;
	                                    case 6:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_file_size_error;
	                                        break;
	                                    case 7:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_nak_limit_reached;
	                                        break;
	                                    case 8:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_inactivity_detected;
	                                        break;
	                                    case 9:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_invalid_file_structure;
	                                        break;
	                                    case 10:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_check_limit_reached;
	                                        break;
	                                    case 11:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                                        break;
	                                    case 12:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_suspend_request_received;
	                                        break;
	                                    case 13:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.condition_code = ConditionCode_cancel_request_received;
	                                        break;
	                                default:                                    /*COVERAGE_IGNORE*/
	                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                    *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                }
	                            } /*COVERAGE_IGNORE*/
	                            if (ret) {
	                                /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_eof_pdu_spare */
	                                {
	                                	static byte tmp[] = {0x00};
	                                    flag bDecodingPatternMatches;
	                                	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 4, &bDecodingPatternMatches);
	                                    ret = ret && bDecodingPatternMatches;
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_SPARE;
	                                }

	                                if (ret) {
	                                    /*Decode file_checksum */
	                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.file_checksum)));
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_FILE_CHECKSUM;
	                                    if (ret) {
	                                        /*Decode file_size */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->payload.u.file_directive.file_directive_pdu.u.eof_pdu.file_size)));
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_EOF_PDU_FILE_SIZE;
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }
	                        else if ((CfdpPDU_payload_file_directive_directive_code == 5)) {
	                            pVal->payload.u.file_directive.file_directive_pdu.kind = FileDirectivePDU_finished_pdu_PRESENT;
	                            /*Decode condition_code */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code)), 4);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;
	                            if (ret) {
	                                switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_condition_code) {
	                                    case 0:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_no_error;
	                                        break;
	                                    case 1:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                                        break;
	                                    case 2:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                                        break;
	                                    case 3:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                                        break;
	                                    case 4:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_filestore_rejection;
	                                        break;
	                                    case 5:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_file_checksum_failure;
	                                        break;
	                                    case 6:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_file_size_error;
	                                        break;
	                                    case 7:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_nak_limit_reached;
	                                        break;
	                                    case 8:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_inactivity_detected;
	                                        break;
	                                    case 9:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_invalid_file_structure;
	                                        break;
	                                    case 10:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_check_limit_reached;
	                                        break;
	                                    case 11:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                                        break;
	                                    case 12:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_suspend_request_received;
	                                        break;
	                                    case 13:
	                                        pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.condition_code = ConditionCode_cancel_request_received;
	                                        break;
	                                default:                                    /*COVERAGE_IGNORE*/
	                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                    *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                }
	                            } /*COVERAGE_IGNORE*/
	                            if (ret) {
	                                /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_finished_pdu_end_system_status */
	                                {
	                                	static byte tmp[] = {0x80};
	                                    flag bDecodingPatternMatches;
	                                	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                    ret = ret && bDecodingPatternMatches;
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_END_SYSTEM_STATUS;
	                                }

	                                if (ret) {
	                                    /*Decode delivery_code */
	                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code)), 1);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;
	                                    if (ret) {
	                                        switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_delivery_code) {
	                                            case 0:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.delivery_code = DeliveryCode_data_complete;
	                                                break;
	                                            case 1:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.delivery_code = DeliveryCode_data_incomplete;
	                                                break;
	                                        default:                                    /*COVERAGE_IGNORE*/
	                                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                            *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_DELIVERY_CODE;                 /*COVERAGE_IGNORE*/
	                                        }
	                                    } /*COVERAGE_IGNORE*/
	                                    if (ret) {
	                                        /*Decode file_status */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status)), 2);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;
	                                        if (ret) {
	                                            switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_finished_pdu_file_status) {
	                                                case 0:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.file_status = FileStatus_discarted_deliberately;
	                                                    break;
	                                                case 1:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.file_status = FileStatus_discarted_file_rejection;
	                                                    break;
	                                                case 2:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.file_status = FileStatus_retained_successfully;
	                                                    break;
	                                                case 3:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.finished_pdu.file_status = FileStatus_unreported;
	                                                    break;
	                                            default:                                    /*COVERAGE_IGNORE*/
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_FINISHED_PDU_FILE_STATUS;                 /*COVERAGE_IGNORE*/
	                                            }
	                                        } /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }
	                        else if ((CfdpPDU_payload_file_directive_directive_code == 6)) {
	                            pVal->payload.u.file_directive.file_directive_pdu.kind = FileDirectivePDU_ack_pdu_PRESENT;
	                            /*Decode directive_code_of_ack_pdu */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.directive_code_of_ack_pdu)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_CODE_OF_ACK_PDU;
	                            if (ret) {
	                                /*Decode directive_subtype_code */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code)), 4);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;
	                                if (ret) {
	                                    switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_directive_subtype_code) {
	                                        case 0:
	                                            pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.directive_subtype_code = DirectiveSubtypeCode_ack_others;
	                                            break;
	                                        case 1:
	                                            pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.directive_subtype_code = DirectiveSubtypeCode_ack_finished;
	                                            break;
	                                    default:                                    /*COVERAGE_IGNORE*/
	                                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                        *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_DIRECTIVE_SUBTYPE_CODE;                 /*COVERAGE_IGNORE*/
	                                    }
	                                } /*COVERAGE_IGNORE*/
	                                if (ret) {
	                                    /*Decode condition_code */
	                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code)), 4);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;
	                                    if (ret) {
	                                        switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_condition_code) {
	                                            case 0:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_no_error;
	                                                break;
	                                            case 1:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_positive_ack_limit_reached;
	                                                break;
	                                            case 2:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_keep_alive_limit_reached;
	                                                break;
	                                            case 3:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_invalid_transmission_mode;
	                                                break;
	                                            case 4:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_filestore_rejection;
	                                                break;
	                                            case 5:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_file_checksum_failure;
	                                                break;
	                                            case 6:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_file_size_error;
	                                                break;
	                                            case 7:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_nak_limit_reached;
	                                                break;
	                                            case 8:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_inactivity_detected;
	                                                break;
	                                            case 9:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_invalid_file_structure;
	                                                break;
	                                            case 10:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_check_limit_reached;
	                                                break;
	                                            case 11:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_unsupported_checksum_type;
	                                                break;
	                                            case 12:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_suspend_request_received;
	                                                break;
	                                            case 13:
	                                                pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.condition_code = ConditionCode_cancel_request_received;
	                                                break;
	                                        default:                                    /*COVERAGE_IGNORE*/
	                                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                            *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_CONDITION_CODE;                 /*COVERAGE_IGNORE*/
	                                        }
	                                    } /*COVERAGE_IGNORE*/
	                                    if (ret) {
	                                        /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_ack_pdu_spare */
	                                        {
	                                        	static byte tmp[] = {0x00};
	                                            flag bDecodingPatternMatches;
	                                        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                                            ret = ret && bDecodingPatternMatches;
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_SPARE;
	                                        }

	                                        if (ret) {
	                                            /*Decode transaction_status */
	                                            ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status)), 2);
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;
	                                            if (ret) {
	                                                switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_ack_pdu_transaction_status) {
	                                                    case 0:
	                                                        pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_undefined;
	                                                        break;
	                                                    case 1:
	                                                        pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_active;
	                                                        break;
	                                                    case 2:
	                                                        pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_terminated;
	                                                        break;
	                                                    case 3:
	                                                        pVal->payload.u.file_directive.file_directive_pdu.u.ack_pdu.transaction_status = AckTransactionStatus_unrecognized;
	                                                        break;
	                                                default:                                    /*COVERAGE_IGNORE*/
	                                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                    *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_ACK_PDU_TRANSACTION_STATUS;                 /*COVERAGE_IGNORE*/
	                                                }
	                                            } /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }
	                        else if ((CfdpPDU_payload_file_directive_directive_code == 7)) {
	                            pVal->payload.u.file_directive.file_directive_pdu.kind = FileDirectivePDU_metadata_pdu_PRESENT;
	                            /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_reserved1 */
	                            {
	                            	static byte tmp[] = {0x00};
	                                flag bDecodingPatternMatches;
	                            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &bDecodingPatternMatches);
	                                ret = ret && bDecodingPatternMatches;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_RESERVED1;
	                            }

	                            if (ret) {
	                                /*Decode closure_requested */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested)), 1);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;
	                                if (ret) {
	                                    switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_closure_requested) {
	                                        case 0:
	                                            pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.closure_requested = ClosureRequested_requested;
	                                            break;
	                                        case 1:
	                                            pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.closure_requested = ClosureRequested_not_requested;
	                                            break;
	                                    default:                                    /*COVERAGE_IGNORE*/
	                                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                        *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CLOSURE_REQUESTED;                 /*COVERAGE_IGNORE*/
	                                    }
	                                } /*COVERAGE_IGNORE*/
	                                if (ret) {
	                                    /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_reserved2 */
	                                    {
	                                    	static byte tmp[] = {0x00};
	                                        flag bDecodingPatternMatches;
	                                    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 2, &bDecodingPatternMatches);
	                                        ret = ret && bDecodingPatternMatches;
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_RESERVED2;
	                                    }

	                                    if (ret) {
	                                        /*Decode checksum_type */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, (&(intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type)), 4);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;
	                                        if (ret) {
	                                            switch (intVal_pVal_payload_u_file_directive_file_directive_pdu_u_metadata_pdu_checksum_type) {
	                                                case 0:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.checksum_type = ChecksumType_modular;
	                                                    break;
	                                                case 1:
	                                                    pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.checksum_type = ChecksumType_none;
	                                                    break;
	                                            default:                                    /*COVERAGE_IGNORE*/
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_CHECKSUM_TYPE;                 /*COVERAGE_IGNORE*/
	                                            }
	                                        } /*COVERAGE_IGNORE*/
	                                        if (ret) {
	                                            /*Decode file_size */
	                                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, (&(pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.file_size)));
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_FILE_SIZE;
	                                            if (ret) {
	                                                /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size */
	                                                ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size)));
	                                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME_SIZE;
	                                                if (ret) {
	                                                    /*Decode source_file_name */
	                                                    ret = ((CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size<=128));
	                                                    if (ret) {
	                                                        pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.nCount = (int)CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_source_file_name_size;
	                                                        ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.arr, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.source_file_name.nCount);
	                                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_SOURCE_FILE_NAME;
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size */
	                                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size)));
	                                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME_SIZE;
	                                                        if (ret) {
	                                                            /*Decode destination_file_name */
	                                                            ret = ((CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size<=128));
	                                                            if (ret) {
	                                                                pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.nCount = (int)CfdpPDU_payload_file_directive_file_directive_pdu_metadata_pdu_destination_file_name_size;
	                                                                ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.arr, pVal->payload.u.file_directive.file_directive_pdu.u.metadata_pdu.destination_file_name.nCount);
	                                                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU_METADATA_PDU_DESTINATION_FILE_NAME;
	                                                            }
	                                                        }   /*COVERAGE_IGNORE*/
	                                                    }   /*COVERAGE_IGNORE*/
	                                                }   /*COVERAGE_IGNORE*/
	                                            }   /*COVERAGE_IGNORE*/
	                                        }   /*COVERAGE_IGNORE*/
	                                    }   /*COVERAGE_IGNORE*/
	                                }   /*COVERAGE_IGNORE*/
	                            }   /*COVERAGE_IGNORE*/
	                        }
	                        else {
	                            *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD_FILE_DIRECTIVE_FILE_DIRECTIVE_PDU;         /*COVERAGE_IGNORE*/
	                            ret = FALSE;                    /*COVERAGE_IGNORE*/
	                        }
	                    }   /*COVERAGE_IGNORE*/
	                }
	                else if ((CfdpPDU_pdu_header_pdu_type == 1)) {
	                    pVal->payload.kind = PayloadData_file_data_PRESENT;
	                    /*Decode file_data_pdu */
	                    ret = cfdpFileDataPDU_ACN_Decode((&(pVal->payload.u.file_data.file_data_pdu)), pBitStrm, pErrCode);
	                }
	                else {
	                    *pErrCode = ERR_ACN_DECODE_CFDPPDU_PAYLOAD;         /*COVERAGE_IGNORE*/
	                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                }
	    			//ret = cfdpPayloadData_ACN_Decode((&(pVal->payload)), &bitStrm, pErrCode);
	                pBitStrm = pBitStrm_save;
	    		}
	    	}
	    }
	}   /*COVERAGE_IGNORE*/

    return ret && cfdpCfdpPDU_IsConstraintValid(pVal, pErrCode);
}


flag cfdpOptions_Equal(const cfdpOptions* pVal1, const cfdpOptions* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0);

}

flag cfdpOptions_IsConstraintValid(const cfdpOptions* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 32);
    *pErrCode = ret ? 0 :  ERR_OPTIONS;

	return ret;
}

#ifdef __cplusplus
const cfdpOptions cfdpOptions_constant = {.nCount = 0, .arr  = {[0 ... 32-1] = 0 }};
#endif

void cfdpOptions_Initialize(cfdpOptions* pVal)
{
	(void)pVal;


	(*(pVal)) = (cfdpOptions)cfdpOptions_constant;
}

flag cfdpOptions_Encode(const cfdpOptions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? cfdpOptions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 32);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpOptions_Decode(cfdpOptions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 32);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OPTIONS;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

	return ret  && cfdpOptions_IsConstraintValid(pVal, pErrCode);
}

flag cfdpOptions_ACN_Encode(const cfdpOptions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? cfdpOptions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 32);
	    ret = BitStream_EncodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag cfdpOptions_ACN_Decode(cfdpOptions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 32);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OPTIONS;
	pVal->nCount = (long)nCount;
	ret = BitStream_DecodeOctetString_no_length(pBitStrm, pVal->arr, pVal->nCount);

    return ret && cfdpOptions_IsConstraintValid(pVal, pErrCode);
}


